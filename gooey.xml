<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>getcuringinfo</name>
			<script>deleteLine()</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>999</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Curing Status:</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>enabled</name>
				<script>gooey.vars.serverSettings.curingEnabled = matches[2]
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Enabled:\s+(Yes|No)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>sip health</name>
				<script>gooey.vars.serverSettings.siphealth = matches[2]</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Sip health at:\s+(\d+)%$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>sip mana</name>
				<script>gooey.vars.serverSettings.sipmana = matches[2]</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Sip mana at:\s+(\d+)%$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>everything else</name>
				<script>deleteLine()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^.*$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>close gate</name>
				<script>setTriggerStayOpen("getcuringinfo", 0)
disableTrigger("getcuringinfo")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string></string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>7</integer>
				</regexCodePropertyList>
			</Trigger>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>My Prompt</name>
			<script>if gmcp and gmcp.Char and gmcp.Char.Vitals and gmcp.Char.Status.name == "Killian" then
  deleteLine()
  if gooey.vars.gmcp.old then
   oldhp = gooey.vars.gmcp.old.hp or tonumber(gmcp.Char.Vitals.hp)
  end
  --some bufer
  cecho("\n                                    ")
  
  --timestamp
  cecho("&lt;black&gt;"..getTime(true, 'hh:mm:ss'))
  
  --target info
  if gmcp.IRE and gmcp.IRE.Target then
    if gmcp.IRE.Target.Set ~= "" and gmcp.IRE.Target.Info.id ~= "-1" then
      cecho("&lt;blaze_orange&gt;"..gmcp.IRE.Target.Info.short_desc.." @ &lt;"..gooey.funcs.healthColor(tonumber(gmcp.IRE.Target.Info.hpperc), 100).."&gt;"..gmcp.IRE.Target.Info.hpperc.."&lt;DimGrey&gt; |")
    end
  end
  
  --health
  cecho(" &lt;"..gooey.funcs.healthColor().."&gt;"..gmcp.Char.Vitals.hp.."/"..gmcp.Char.Vitals.maxhp.."H "..gooey.funcs.round(tonumber(gmcp.Char.Vitals.hp)/tonumber(gmcp.Char.Vitals.maxhp)*100).."% ")
  --mana
  cecho("&lt;a_onelevel&gt;"..gmcp.Char.Vitals.mp.."/"..gmcp.Char.Vitals.maxmp.."M ")
  --missing bal or eq?
  if gmcp.Char.Vitals.bal == "0" or gmcp.Char.Vitals.eq == "0" then 
    cecho("&lt;DimGrey&gt;|") 
  end
  --balance
  cecho("&lt;DimGrey&gt;"..((gmcp.Char.Vitals.bal == "1") and "" or "&lt;DimGrey&gt; -bal"))
  --eq
  cecho("&lt;DimGrey&gt;"..((gmcp.Char.Vitals.eq == "1") and "" or "&lt;DimGrey&gt;-eq"))
  --did our health change?
  if oldhp ~= tonumber(gmcp.Char.Vitals.hp) then
    cecho("&lt;DimGrey&gt; | &lt;DarkSlateGray&gt;("..(tonumber(gmcp.Char.Vitals.hp)-oldhp).."h)")
  end
  oldhp = tonumber(gmcp.Char.Vitals.hp)
end</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string></string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>7</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Touch starbrust</name>
			<script>send("touch starburst", false)</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^As the starburst tattoo's shape is codified on the \w+ of yourself, the last of the ink leaves the air and you pause for a moment to admire your handiwork.$</string>
				<string>^As the starburst tattoo's shape is codified on your \w+</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Wilderness Map</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>GMCP Map Catchers</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>return gmcp.Room</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>4</integer>
				</regexCodePropertyList>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>GMCP Rooms</name>
					<script>if gooey.gui.map.current ~= "Mapper" then
  gooey.gui.map[gooey.gui.map.current]:hide()
end
gooey.gui.map.current = "Mapper"
gooey.gui.map["Mapper"]:show()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>return gmcp.Room.Info.num &lt; 2121028</string>
						<string>return gmcp.Room.Info.num &gt; 0</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>4</integer>
						<integer>4</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>GMCP Wilderness</name>
					<script>if gooey.gui.map.current ~= "Wilderness" then
  gooey.gui.map[gooey.gui.map.current]:hide()
end
gooey.gui.map.current = "Wilderness"
gooey.gui.map["Wilderness"]:show()


--2044146
--2024249
--2106249
--2023249</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>return gmcp.Room.Info.num &gt; 2121028</string>
						<string>return gmcp.Room.Info.coords==""</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>4</integer>
						<integer>4</integer>
					</regexCodePropertyList>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Wilderness Catch All</name>
						<script>for i=1, 50 do
	selectString("\^", i) 
	fg("black")
	bg("black")
	resetFormat()
end

for i=1, 50 do
	selectString("\?", i) 
	fg("red")
	bg("black")
	resetFormat()
end


selectCurrentLine()
copy()
appendBuffer("Wilderness")
deleteLine()

</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^[ wnmjSIMXWYx',;#=@~%!\.\^\|\*\?\+\(]+$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>GMCP Oceans</name>
					<script>if gooey.gui.map.current ~= "Ocean" then
  gooey.gui.map[gooey.gui.map.current]:hide()
end
gooey.gui.map.current = "Ocean"
gooey.gui.map["Ocean"]:show() </script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>return gmcp.Room.Info.environment=='Vessel'</string>
						<string>return gmcp.Room.Info.num==-2</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>4</integer>
						<integer>4</integer>
					</regexCodePropertyList>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Ocean Catch All</name>
						<script>selectCurrentLine()

for i=1, 50 do
	 selectString("#", i) 
	 fg("ansiCyan")
	 bg("NavyBlue")
	 resetFormat()
  end

for i=1, 50 do
	selectString("\^", i) 
	fg("black")
	bg("black")
	resetFormat()
end

for i=1, 50 do
	selectString("\?", i) 
	fg("red")
	bg("black")
	resetFormat()
end

for i=1, 50 do
	selectString("S", i) 
	fg("red")
	bg("yellow")
	resetFormat()
end

if maplen == 13 then
  for i=1, 50 do
	 selectString("w", i) 
	 fg("ansiCyan")
	 bg("NavyBlue")
	 resetFormat()
  end
  for i=1, 50 do
	 selectString("(", i) 
	 fg("red")
	 bg("gray")
	 resetFormat()
  end
  for i=1, 50 do
	 selectString("#", i) 
	 fg("blue")
	 bg("gray")
	 resetFormat()
  end
end

selectCurrentLine()
copy()
appendBuffer("Ocean")
deleteLine()
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^[ wnmjSIMXWYx',;#=@~%!\.\^\|\*\?\+\(]+$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</Trigger>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Ship Room Detected</name>
				<script>clearWindow("Wilderness") </script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Quarterdeck</string>
					<string>Main deck</string>
					<string>Side deck</string>
					<string>Stern</string>
					<string>Ship bow</string>
					<string>The ship moves</string>
					<string>The ship drifts</string>
					<string>Crow's nest.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>We're blind, fo'</name>
			<script>send("touch mindseye")</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^You\? As blind as a bat. Doing what\?$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Sea</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Battle Prompt</name>
				<script>--selectCurrentLine()
--copy()
--appendBuffer("myPrompt")
--fg("a_onelevel")
--cinsertText("                             ")
--deleteLine()
gooey.vars = gooey.vars or {}
gooey.vars.sea = gooey.vars.sea or {}
gs = gooey.vars.sea
gs.shipSails = matches[2]
gs.windSpeed = matches[6]
gs.windDir = matches[5]
gs.shipSpeed = matches[8]
gs.shipCourse = matches[7]
gs.seasTranl = matches[9]
gs.shipState = matches[10]
gs.shipAction = matches[11]
gs.seas = nil
gs.myhullis = gs.myhullis or 0
gs.oldhull = gs.oldhull or gs.hull

if string.find(gs.shipState, "Row") then rowing = true
else rowing = false
end

if matches[2] == "Full" then gs.shipSails = "Full"
  elseif matches[2] == "Furl" then gs.shipSails = "Furled"
  else gs.shipSails = tonumber(matches[3])
end

if matches[3] == "full" then gs.sails = 100
elseif matches[3] == "gone" then gs.sails = 0
else gs.sails = tonumber(matches[3])
  if gs.gottaclearrigs and gs.sails &gt; 30 then
    expandAlias("clr")
    gs.gottaclearrigs = false
  end
end

if gs.hull then gs.oldhull = gs.hull end

if matches[4] == "full" then gs.hull = 100
else gs.hull = tonumber(matches[4])
end


if gs.hull &lt; 98 then 
  if  not (gs.repairingHull or gs.startedShooting or gs.clearingSomething) then
    send("ship repair all",true)
    cecho("\n&lt;DarkSlateGray&gt;Crew: &lt;ansiYellow&gt;Starting repairs, captain!")
    gs.repairingHull = true
  end
elseif gs.hull == 100 then
  gs.repairingHull = false
end

if gs.oldhull and gs.hull - gs.oldhull ~= 0 then cecho("\n&lt;DimGrey&gt;Hull: "..(gs.hull - gs.oldhull &gt; 0 and ("&lt;cyan&gt;+"..gs.hull - gs.oldhull) or ("&lt;yellow&gt;"..gs.hull - gs.oldhull))) end

gooey.funcs.showActivity()

if gs.hull &gt; 55 then
alerted50 = false
alerted40 = false
alerted30 = false
alerted20 = false
alerted10 = false
end


if not alerted50 and gs.hull &lt; 50 then 
  playsound("Low hull.wav")
  alerted50 = true
end
if not alerted40 and gs.hull &lt; 40 then 
  playsound("Low hull.wav")
  alerted40 = true
end
if not alerted30 and gs.hull &lt; 30 then 
  playsound("Low hull.wav")
  alerted30 = true
end
if not alerted20 and gs.hull &lt; 20 then 
  playsound("Low hull.wav")
  alerted20 = true
end
if gs.hull &lt; 10 then 
  playsound("Low hull.wav")
  alerted10 = true
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^= Sl (\d+|\w+)%? - hp +(\d+|\w+)%?,Hl: +(\d+|\w+)%?,Wd (\w+)@(\d+\w+),Cr\/Sp (\w+)@(\d+),Sea (\w+),?(.*),?(.*)$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>curingEnabled</name>
			<script>gooey.serverSettings.curingEnabled = (matches[2] == "activated" and "Yes" or "No")</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Curing (disabled|activated)\.$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
	</TriggerPackage>
	<TimerPackage>
		<TimerGroup isActive="yes" isFolder="yes" isTempTimer="no" isOffsetTimer="no">
			<name>gooey</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<time>00:00:00.000</time>
		</TimerGroup>
	</TimerPackage>
	<AliasPackage>
		<Alias isActive="yes" isFolder="no">
			<name>Toggle pause curing</name>
			<script>if matches[2] == nil or "" then gooey.funcs.pp() 
else gooey.funcs.pp(matches[2]) end</script>
			<command></command>
			<packageName></packageName>
			<regex>^pp ?(o(n|ff))?</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>firework</name>
			<script>-- Function to print a colored string
function printColored(text, color)
    cecho("&lt;" .. color .. "&gt;" .. text .. "&lt;reset&gt;")
end

-- Function to create a better approximation of a round burst of color for a firework
function drawRoundFirework()
    local colors = {"red", "green", "yellow", "blue", "magenta", "cyan", "white"}
    
    local explosion = "*"
    local radius = 10
    
    for i = -radius, radius do
        local spaces = math.ceil(math.sqrt(radius^2 - i^2))
        local fireworksLine = string.rep(" ", spaces) .. explosion
        printColored(fireworksLine, colors[math.random(#colors)])
        os.execute("sleep 0.1")  -- Adjust the sleep duration if needed
        cecho("\n")
    end
end

-- Call the function to draw the improved round firework burst
drawRoundFirework()
</script>
			<command></command>
			<packageName></packageName>
			<regex>^firework</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>Shipon</name>
			<script>if matches[2] == "n" then
  gooey.vars.sea.shipOn = true
else gooey.vars.sea.shipOn = false 
end

gooey.funcs.echo((gooey.vars.sea.shipOn and "We're on a ship!" or "We're not on a ship"))</script>
			<command></command>
			<packageName></packageName>
			<regex>^shipo(n|ff)$</regex>
		</Alias>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Main gooey</name>
			<packageName></packageName>
			<script>----------------------------------
--  Heavily inspired by Zulah   --
--  ...and all the people       --
--    cause I can't code.       --
----------------------------------</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>AdjustableTabWindow</name>
				<packageName></packageName>
				<script>-- Adjustable TabWindow
-- TabWindow code by Mudlet Wiki
-- other functions
-- by Edru 10th October 2020
-- https://github.com/Edru2/AdjustableTabWindow 

Adjustable = Adjustable or {}
Adjustable.TabWindow = Adjustable.TabWindow or Geyser.Container:new({name = "AdjustableTabWindowClass"})
local tab_pos = nil

function Adjustable.TabWindow:createBaseContainers()
    self.tabBar = self.tabBar or Geyser.Label:new({        
        name = self.name.."tabBar",
        x = 0, y = 0,
        width = "100%",
        height = self.tabBarHeight,
    },self)
    self.tabBar:setStyleSheet(self.tabBarStyle)
    
    self.header = self.header or Geyser.HBox:new({
        name = self.name.."header",
        x = 0, y = 0,
        width = "100%",
        height = "100%",
    },self.tabBar)
    
    self.overlay = self.overlay or Geyser.Label:new({
        name = self.name.."overlay",
        x = 0, y = 0,
        width = "100%",
        height = "100%",
    },self.tabBar)
    
    self.overlay:setStyleSheet(self.overlayStyle)
    self.overlay:setMoveCallback(function(event) self:onOverlayMove(event) end)
    self.overlay:setOnLeave(function(event) self:onOverlayLeave(event) end)
    self.overlay:setClickCallback(function(event) self:onOverlayClick(event) end)
    self.overlay:hide()
    
    self.footerContainer = self.footerContainer or Geyser.Container:new({
        name = self.name.."footerContainer",
        x = 0, y = self.tabBarHeight,
        width = "100%",
        height = "-0",
    },self)
    
    self.footer = self.footer or Geyser.Label:new({
        name = self.name.."footer",
        x = 0, y = self.gap,
        width = "100%",
        height = "-0",
    },self.footerContainer)
    
    self.footer:setStyleSheet(self.footerStyle)
end

local function setTabToolTip(tab)
    -- put ToolTip on Label if TabText is to long to display
    local w,h = calcFontSize(tab.adjLabel.fontSize)
    local txt_width = #tab.tabText * w
    if tab.adjLabel:get_width() &lt; txt_width then
        tab.adjLabel:setToolTip(tab.tabText)
    else
        tab.adjLabel:resetToolTip()
    end
end

-- function to create new tabs in tabs table or to rewrite/readjust them
function Adjustable.TabWindow:createTabs()
    for k,v in ipairs(self.tabs) do
        self[v.."center"] = self[v.."center"] or Geyser.Label:new({
            name = v.."center",
            x = 0, y = 0,
            width = "100%",
            height = "100%",
        },self.footer)
        
        self[v.."center"]:setStyleSheet(self.centerStyle)
        
        local tabText = self[v] and self[v].tabText or v
        
        self[v] = self[v] or Adjustable.Container:new({
            name = self.name.." Tab: "..v,
            tabname = v,
            origin = self,
            noLimit = true,
            tabText = tabText,
            padding = 0,
            locked = true,
            autoSave = false,
            autoLoad = false,
            raiseOnClick = false,
            adjLabelstyle = self.inactiveTabStyle,
            titleTxtColor = self.tabTxtColor
            
        }, self.header)
        
        self[v]:setTitle("", self.TabTxtColor)
        self[v].titleText = "&amp;nbsp;&amp;nbsp;"..tabText
        self[v].adjLabel:echo(tabText, self.TabTxtColor)
        self[v]:newLockStyle("tab", 
        function(self)         
            self.Inside:resize("-"..self.padding,"-"..self.padding)
            self.Inside:move(self.padding, self.padding*2) 
        end)
        
        self[v].lockStyle = "tab"
        
        self[v].unlockContainer = function()
            Adjustable.Container.unlockContainer(self[v])
            self[v]:setTitle("", self.tabTxtColor)
            self[v].titleText = ("&amp;nbsp;&amp;nbsp;"..self[v].tabText)
            self[v].adjLabel:echo(self[v].tabText, "nocolor", "c")
        end
        
        
        Adjustable.TabWindow.allTabs[v] = self
        
        self[v]:newCustomItem("Tabify", function() Adjustable.TabWindow.allTabs[v]:createTempWindow(self[v]) end)
        
        self[v].reposition = self.reposition
        local delIndex = table.index_of(Adjustable.Container.all_windows, self[v].name)
        if delIndex then
            table.remove(Adjustable.Container.all_windows, delIndex)
        end
        Adjustable.Container.all[self[v].name] = nil
        self[v].adjLabelstyle = self.inactiveTabStyle
        self[v].titleTxtColor = self.tabTxtColor
        self[v].adjLabel:setStyleSheet(self.inactiveTabStyle)
        
        self[v].adjLabel:echo(self[v].tabText, "nocolor", "c")
        self[v].adjLabel:setClickCallback(function(event) self:onClick(v, event) end)
        self[v].adjLabel:setReleaseCallback(function(event) self:onRelease(v, event) end)
        self[v].adjLabel:setMoveCallback(function(event) self:onMove(v, event) end)
        self[v].adjLabel:setDoubleClickCallback(function(event) self:onDoubleClick(v, event) end)
        self[v].minimizeLabel:setClickCallback(function() self:onMinimizeClick(v) end)
        self[v].minimizeLabel:echo("&lt;center&gt;🗗&lt;/center&gt;")
        self[v].minLabel:setClickCallback(function() self:onMinimizeClick(v) end)
        self[v.."center"]:hide()        
        -- put ToolTip on Label if TabText is to long to display
        setTabToolTip(self[v])
    end
end


--- Sets the amount of space to use between the tabs and the consoles
-- @tparam number gap Number of pixels to keep between the tabs and consoles
function Adjustable.TabWindow:setGap(gap)
    local gapNumber = tonumber(gap)
    local gapType = type(gap)
    assert(gapType == "number", "gap expected as number, got " .. gapType)
    self.gap = gapNumber
    self.footer:move(0, gapNumber)
end

--- Sets the height of the tabs in pixels/percent
-- @tparam number tabHeight the height of the tabs for the object, in pixels/percent
function Adjustable.TabWindow:setTabHeight(tabHeight)
    self.tabBarHeight = tabHeight
    self.tabBar:resize("100%", tabHeight)
    self.footerContainer:move(0, tabHeight)
    self.footerContainer:resize("100%", "-0")
end


--- Sets the CSS to use for the tab box which contains the tabs for the object
-- @tparam string css The css styling to use for the tab box
function Adjustable.TabWindow:setTabBarCSS(css)
    local cssType = type(css)
    assert(cssType == "string", "css as string expected, got " .. cssType)
    self.tabBarStyle = css
    self.tabBar:setStyleSheet(self.tabBarStyle)
end

--- Sets the color to use for the tab box background
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function Adjustable.TabWindow:setTabBarColor(color)
    self.tabBarColor = color
    self.tabBarStyle = ""
    self.tabBar:setStyleSheet(self.tabBarStyle)
    self.tabBar:setColor(self.tabBarColor)
end

--- Sets the FG color for the active tab
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function Adjustable.TabWindow:setActiveTabFGColor(color)
    local found
    local add_css
    local r, g, b = Geyser.Color.parse(color)
    local rgb = string.format("rgb(%s, %s, %s)",r,g,b)
    self.activeTabFGColor = color
    self.activeTabStyle, found = string.gsub(" "..self.activeTabStyle, "(%scolor:).-(;)","%1"..rgb.."%2")
    if found == 0 then
        if string.match(self.activeTabStyle,"QLabel{") then
            add_css = "\nQLabel{color:"..rgb..";}"
        else
            add_css = "\ncolor:"..rgb..";"
        end
        self.activeTabStyle = self.activeTabStyle..add_css
    end
    self:adjustTabStyle()
end

--- Sets the FG color for the inactive tab
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function Adjustable.TabWindow:setInactiveTabFGColor(color)
    local found
    local add_css
    self.inactiveTabFGColor = color
    local r, g, b = Geyser.Color.parse(color)
    local rgb = string.format("rgb(%s, %s, %s)",r,g,b)
    
    self.inactiveTabStyle, found = string.gsub(" "..self.inactiveTabStyle, "(%scolor:).-(;)","%1"..rgb.."%2") 
    if found == 0 then
        if string.match(self.inactiveTabStyle,"QLabel{") then
            add_css = "\nQLabel{color:"..rgb..";}"
        elseif string.match(self.inactiveTabStyle,"QLabel::!hover{") then
            add_css = ""
            self.inactiveTabStyle = string.gsub(self.inactiveTabStyle, "(QLabel::!.-)(})","%1".."color:"..rgb..";".."%2")
        else 
            add_css = "\ncolor:"..rgb..";"
        end
        self.inactiveTabStyle = self.inactiveTabStyle..add_css
    end
    self:adjustTabStyle()
end

--- Sets the BG color for the active tab.
-- &lt;br&gt;NOTE: If you set CSS for the active tab, it will override this setting.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function Adjustable.TabWindow:setActiveTabBGColor(color)
    self.activeTabBGColor = color
    local r, g, b = Geyser.Color.parse(color)
    local rgba = string.format("rgba(%s, %s, %s, %s)",r,g,b,"100%%")
    self.activeTabStyle = string.gsub(self.activeTabStyle, "(background%-color:.-).-(;)","%1 "..rgba.."%2")
    self:adjustTabStyle()
end

--- Sets the BG color for the inactive tab.
-- &lt;br&gt;NOTE: If you set CSS for the inactive tab, it will override this setting.
-- @param color Color string suitable for decho or hecho, or color name eg "purple", or table of colors {r,g,b}
function Adjustable.TabWindow:setInactiveTabBGColor(color)
    self.inactiveTabBGColor = color
    local r, g, b = Geyser.Color.parse(color)
    local rgba = string.format("rgba(%s, %s, %s, %s)",r,g,b,"100%%")
    self.inactiveTabStyle = string.gsub(self.inactiveTabStyle, "(background%-color:.-).-(;)","%1 "..rgba.."%2")
    self:adjustTabStyle()
end

function Adjustable.TabWindow:adjustTabStyle()
    local abg_rgb = string.match(self.activeTabBGColor, "%d+.-%d+.-%d+")
    local ibg_rgb = string.match(self.inactiveTabBGColor, "%d+.-%d+.-%d+")
    for k,v in ipairs(self.tabs) do
        if v == self.current then
            self[v].adjLabelstyle = self.activeTabStyle
            self[v].adjLabel:setStyleSheet(self.activeTabStyle)
            if abg_rgb then
                self[v].adjLabel:setColor("&lt;"..abg_rgb.."&gt;")
            else
                self[v].adjLabel:setColor(self.activeTabBGColor)
            end
        else
            self[v].adjLabelstyle = self.inactiveTabStyle
            self[v].adjLabel:setStyleSheet(self.inactiveTabStyle)
            if ibg_rgb then
                self[v].adjLabel:setColor("&lt;"..ibg_rgb.."&gt;")
            else
                self[v].adjLabel:setColor(self.inactiveTabBGColor)
            end
        end
    end
end

--- sets the font for all tabs
--- @tparam string font the font to use.
function Adjustable.TabWindow:setTabFont(font)
    self.tabFont = font
    for k,v in ipairs(self.tabs) do
        self[v].adjLabel:setFont(font)
    end
end

--- sets the font for a single tab. If you use setTabFont this will be overridden
--- @tparam string tabName the tab to change the font of
--- @tparam string font the font to use for that tab
function Adjustable.TabWindow:setSingleTabFont(tabName, font)
    local funcName = "EMCO:setSingleTabFont(tabName, font)"
    if not table.contains(self.tabs, tabName) then
        error("tabName must be an existing tab")
    end
    self[tabName].adjLabel:setFont(font)
end

-- finds the right position to drop the tab into
function Adjustable.TabWindow:findPosition(tab)
    local myWindow = Adjustable.TabWindow.currentWindow or self
    local x, w = myWindow.get_x(), myWindow.get_width()
    local total = w/#myWindow.tabs
    local tab_x = tab.get_x() - x
    local position = (tab_x/total) + 1
    position = math.floor(position + 0.5)
    if position &lt; 1 then
        position = 1
    end
    if position &gt; #myWindow.tabs then
        position = #myWindow.tabs + 1
    end
    return position
end

-- checks if 2 elements collide
local function checkCollision(x1,y1,w1,h1, x2,y2,w2,h2)
    if  x1 &lt; x2+w2 and
    x2 &lt; x1+w1 and
    y1 &lt; y2+h2 and
    y2 &lt; y1+h1 then
        return true
    end
end

local function getFloatingWindows()
    local floatingWindows = {}
    for k,v in pairs(Adjustable.TabWindow.allTabs) do
        if v[k].floating then
            floatingWindows[k] = v[k]
        end
    end
    return floatingWindows
    
end

-- checks if your tab collides with one of the tabwindows
function Adjustable.TabWindow:checkMultiCollision(tab)
    local floatingWindows = getFloatingWindows()
    local x1, y1, w1, h1 = tab:get_x(), tab:get_y(), tab:get_width(), tab:get_height()
    for k,v in pairs(floatingWindows) do
        local x2, y2, w2, h2 = v:get_x(), v:get_y(), v:get_width(), v:get_height()   
        if checkCollision(x1,y1,w1,h1, x2,y2,w2,h2) and v.windowname == self.windowname and not(v.hidden or v.auto_hidden) and not (v == tab) and not v.locked then
            return "floating", v
        end
    end  
    for k,v in pairs(Adjustable.TabWindow.all) do
        local x2, y2, w2, h2 = v:get_x(), v:get_y(), v:get_width(), v:get_height()
        
        if checkCollision(x1,y1,w1,h1, x2,y2,w2,h2) and v.windowname == self.windowname and not(v.hidden or v.auto_hidden) then
            return "TabWindow", v
        end
    end  
end

-- onMove function
-- contains all the functionality to move the tab (collision check, make space ...)
function Adjustable.TabWindow:onMove(tab, event)
    self[tab]:onMove(self[tab].adjLabel, event)
    self[tab].adjLabel:setAlignment("c")
    if self[tab].floating or not Adjustable.TabWindow.clicked then
        return
    end
    local result, value = self:checkMultiCollision(self[tab])
    if Adjustable.TabWindow.currentWindow and Adjustable.TabWindow.currentWindow ~= value and not Adjustable.TabWindow.currentWindow.floating then
        -- reset the tab space
        self:makeSpace(Adjustable.TabWindow.currentWindow, nil, true)
    end
    if result == "TabWindow" then
        Adjustable.TabWindow.currentWindow = value
        tab_pos = value:findPosition(self[tab])
        self:makeSpace(value, tab_pos)
        return
    end
    if result == "floating" and not(value.locked) then
        Adjustable.TabWindow.currentWindow = value
        return
    end    
    if Adjustable.TabWindow.currentWindow then
        Adjustable.TabWindow.currentWindow = nil
    end
end

--- Transforms a floating Tab into a temporary TabWindow
-- @tparam tab the tab which will be transformed
function Adjustable.TabWindow:createTempWindow(tab, tempName)
    if tab and not(tab.floating) then
        return
    end
    
    local rnd_nr = 0
    for i=0,#Adjustable.TabWindow.all_windows do
        if not Adjustable.TabWindow.all["tempTabWindow"..i] then
            rnd_nr = i
            break
        end
    end
    
    local window = tab and tab.windowname ~= "main" and Geyser.windowList[tab.windowname.."Container"].windowList[tab.windowname] or Geyser
    local tempWindowName = tempName and "tempWindow"..string.match(tempName,"%d+") or "tempWindow"..rnd_nr
    local tempTabWindowName = tempName or "tempTabWindow"..rnd_nr
    local x, y, width, height = 0,0,100,100
    if tab then
        x, y, width, height = tab:get_x(), tab:get_y(), tab:get_width(), tab:get_height()
    end
    local tempWindowConf = { name = tempWindowName,
    titleText = "",
    x = x,
    y = y, 
    width = width, 
    height = height,
    autoSave = false,
    autoLoad = false,
}
tempWindowConf = table.union(tempWindowConf, self.tempWindowConf)

local windowCont = Adjustable.Container:new(tempWindowConf)
windowCont:move(x, y)
windowCont:resize(width, height)
table.remove(Adjustable.Container.all_windows, table.index_of(Adjustable.Container.all_windows, windowCont.name ))
Adjustable.Container.all[windowCont.name] = nil

local tabWindow = Adjustable.TabWindow:new({
    name = tempTabWindowName,
    x = 0, 
    y = 0, 
    width = "100%", 
    height = "100%",
    tabTxtColor 		= self.tabTxtColor,
    tabPadding 		    = self.tabPadding,
    activeTabFGColor 	= self.activeTabFGColor,
    inactiveTabFGColor 	= self.inactiveTabFGColor, 
    activeTabBGColor 	= self.activeTabBGColor, 
    inactiveTabBGColor 	= self.inactiveTabBGColor, 
    tabBarColor 		= self.tabBarColor,    
    tabBarStyle 		= self.tabBarStyle, 
    color1 			    = self.color1, 
    color2 			    = self.color2, 
    tabBarHeight 		= self.tabBarHeight, 
    footerStyle 		= self.footerStyle, 
    centerStyle 		= self.centerStyle,
    inactiveTabStyle 	= self.inactiveTabStyle, 
    activeTabStyle 		= self.activeTabStyle, 
    chosenTabStyle 		= self.chosenTabStyle,  
    overlayStyle 		= self.overlayStyle,  
    gap 		 	    = self.gap, 
    temporary = true 
}, windowCont) 

--save name to get the style on loading
tabWindow.tempStyle = self.tempStyle or self.name 
if tab then
    self:restoreTab(tab.tabname, tabWindow)
    tab.tempWindow = windowCont
    tab.tempTabWindow = tabWindow
    tab.tempWindow:changeContainer(window)
    tab.tempWindow:setPercent(true, true)
end
windowCont:show()
windowCont.tabWindow = tabWindow
return windowCont
end

-- mouse movement on the overlay label
function Adjustable.TabWindow:onOverlayMove(event)  
    Adjustable.TabWindow.currentWindow = self
    local tab = Adjustable.TabWindow.clickedTab.name
    if Adjustable.TabWindow.clickedTab ~= self.header.windowList[tab] then
        -- need to feed values to findPosition
        local fakeTab = {}
        fakeTab.get_x = function() return event.x + self.header.get_x() end    
        tab_pos = self:findPosition(fakeTab)
        self:makeSpace(self, tab_pos)
    end
end

-- reset tabspace after mouse leaves overlay label and resets the currentWindow
function Adjustable.TabWindow:onOverlayLeave(event)
    Adjustable.TabWindow.currentWindow = nil
    if not(Adjustable.TabWindow.doubleClick) then
        return
    end
    local tab = Adjustable.TabWindow.clickedTab.name
    if Adjustable.TabWindow.clickedTab ~= self.header.windowList[tab] then
        self:makeSpace(nil, nil, true)
    end
end

-- reset the Overlay label to be hidden
local function resetOverlay()
    local tab = Adjustable.TabWindow.clickedTab
    if Adjustable.TabWindow.overlayTimer then
        killTimer(Adjustable.TabWindow.overlayTimer)
        Adjustable.TabWindow.overlayTimer = nil
    end
    for k,v in pairs(Adjustable.TabWindow.all) do 
        v.overlay:setStyleSheet("background-color: rgba(0,0,0,0%);") 
        v.overlay:hide()
    end  
    if Adjustable.TabWindow.currentWindow then
        Adjustable.TabWindow.currentWindow:makeSpace(nil, nil, true)
    end
    Adjustable.TabWindow.doubleClick = nil
    tab_pos = nil
    
    -- reset Style if overlay is resetet without action
    if tab then
        tab.adjLabel:setStyleSheet(tab.adjLabelstyle)
    end
    
    if Adjustable.TabWindow.MouseEventID then     
        killAnonymousEventHandler(Adjustable.TabWindow.MouseEventID)
        Adjustable.TabWindow.MouseEventID = nil
    end
end

-- handles on overlay click event
function Adjustable.TabWindow:onOverlayClick(event) 
    Adjustable.TabWindow.doubleClick = nil
    local tab = Adjustable.TabWindow.clickedTab
    local container = Adjustable.TabWindow.allTabs[tab.tabname] or self
    tab.adjLabel:setStyleSheet(container.activeTabStyle)
    if container[tab.tabname].floating then
        container:restoreTab(tab.tabname, self)
        self:addTab(tab.tabname, tab_pos)
    else
        container:onRelease(tab.tabname, event)
    end
    resetOverlay()
end

-- if clicked on the minimize label the tab will be 
-- restored to be in a tabwindow again
function Adjustable.TabWindow:onMinimizeClick(tab)  
    local result, value = self:checkMultiCollision(self[tab])
    if result == "floating" then
        value = nil
    end
    self:restoreTab(tab, value)
end

-- activates the tab tab (doesn't deactivate the previous tab)
-- @see Adjustable.TabWindow:deactivateTab()
function Adjustable.TabWindow:activateTab(tab)
    self:deactivateTab()
    tab = self[tab] and tab or self.tabs[1]
    self.current = tab
    if self.current then
        self[tab].adjLabelstyle = self.activeTabStyle
        self[tab].adjLabel:setStyleSheet(self.activeTabStyle)
        self[self.current.."center"]:show()
    end
    self:raiseAll()
end

-- deactivates and hides the current active tab
function Adjustable.TabWindow:deactivateTab()
    if self.current and self[self.current] then  
        self[self.current].adjLabelstyle = self.inactiveTabStyle
        self[self.current].adjLabel:setStyleSheet(self.inactiveTabStyle)
        self[self.current.."center"]:hide()
    end
end

-- handles click event on tab
function Adjustable.TabWindow:onClick(tab, event)
    if Adjustable.TabWindow.doubleClick then
        return
    end
    Adjustable.TabWindow.currentWindow = self
    Adjustable.TabWindow.clicked = true
    Adjustable.TabWindow.clickedTab = self[tab]
    if event.button == "LeftButton" and not self[tab].floating then
        self[tab]:resize(self[tab].get_width(),self[tab].get_height())
        self[tab].container = Geyser
        -- set minimized to true to prevent resizing
        self[tab].minimized = true
        self[tab]:unlockContainer()
        self[tab]:onClick(self[tab].adjLabel, event)
        self[tab].exitLabel:hide()
        self[tab].minimizeLabel:hide()
        Adjustable.TabWindow.clicked = true
        Adjustable.TabWindow.clickedTab = self[tab]
        self[tab].adjLabel:echo(self[tab].tabText, "nocolor", "c")
    end
    
    if self[tab].floating then
        self[tab]:onClick(self[tab].adjLabel, event)
    end
    if not self[tab].floating then
        self:activateTab(tab)
        self[tab].adjLabel:raise(false)
    end
end

-- handles double click event on getAreaTable
-- activates the tab overlay
function Adjustable.TabWindow:onDoubleClick(tab, event)
    Adjustable.TabWindow.currentWindow = self
    Adjustable.TabWindow.doubleClick = true
    Adjustable.TabWindow.clickedTab = self[tab]
    self[tab].adjLabel:setStyleSheet(self.chosenTabStyle)
    for k,v in pairs(Adjustable.TabWindow.all) do
        v.overlay:show()
        v.overlay:raise()
        v.overlay:setStyleSheet(v.overlayStyle)
    end
    Adjustable.TabWindow.overlayTimer = Adjustable.TabWindow.overlayTimer or tempTimer(10, function() resetOverlay() end )
    Adjustable.TabWindow.MouseEventID = Adjustable.TabWindow.MouseEventID or registerAnonymousEventHandler("sysWindowMousePressEvent", "Adjustable.TabWindow.onMouseClick", true)
end

-- handles the mouseclick event 
-- used for sending windows to the main or userwindow after using doubleclick on a tab
function Adjustable.TabWindow.onMouseClick( event, button, x, y, windowname )
    local newContainer = Geyser
    if windowname ~= "main" then
        newContainer = Geyser.windowList[windowname.."Container"].windowList[windowname]
    end 
    local tab = Adjustable.TabWindow.clickedTab
    local container = Adjustable.TabWindow.allTabs[tab.tabname]
    
    container:transformTabContainer(tab.tabname)   
    local width, height = math.min(newContainer.get_width(), tab:get_width()), math.min(newContainer.get_height(), tab:get_height())
    
    tab:changeContainer(newContainer)
    tab:raiseAll()
    local x = math.min(newContainer.get_width() - width, math.max(0, x - width/2))
    local y = math.min(newContainer.get_height() - height, math.max(0, y))
    tab:move(x, y)
    tab:resize(width, height)
    tab:setPercent(true,true)
    killAnonymousEventHandler(Adjustable.TabWindow.MouseEventID)
    Adjustable.TabWindow.MouseEventID = nil
    resetOverlay()
end

-- transforms the tab to a window
function Adjustable.TabWindow:transformTabContainer(tab)
    local myWindow = Adjustable.TabWindow.allTabs[tab] or self
    local container = self[tab]
    if container.windowname == "main" then
        Geyser:add(container)
    else
        Geyser.windowList[container.windowname.."Container"].windowList[container.windowname]:add(container)
    end
    container:unlockContainer()
    container:resize(self.get_width(), self.get_height())
    container:add(self[tab.."center"])
    myWindow:removeTab(tab)
    myWindow:createTabs()
    container:setPadding(self.tabPadding)
    container:show()
    container:raiseAll()
    myWindow[tab].floating = true
    container.raiseOnClick = true
    container.adjLabel:echo(self[tab].tabText, "nocolor", "c")
    container.adjLabel:resetToolTip()
    container.minimized = false
    container:setPercent(true, true)
    myWindow:activateTab(tab)
    if #myWindow.tabs &gt; 0 then
        myWindow:activateTab(myWindow.tabs[1])
    else 
        myWindow.current = nil
    end
    local found
    container.adjLabelstyle, found = string.gsub(self.activeTabStyle, "(qproperty%-alignment%:.-).-(;)","%1 'AlignTop' %2")
    if found == 0 then
        container.adjLabelstyle = container.adjLabelstyle.."\nqproperty-alignment: 'AlignTop' ;\n"
    end
    container.adjLabel:setStyleSheet(container.adjLabelstyle)
    self[tab.."center"]:show()
end

--restores the window to be a tab again
function Adjustable.TabWindow:restoreTab(tab, myWindow)
    myWindow = myWindow or self
    local container = self[tab]
    container.container:remove(container)
    container:remove(self[tab.."center"])
    container:setPadding(0)
    container:lockContainer()
    container:detach()
    container:disconnect()
    container.adjLabel:echo(self[tab].tabText, "nocolor", "c")
    self:changeTabContainer(tab, myWindow)
    self[tab].floating = false
    container.raiseOnClick = false
    tempTimer(0, function() myWindow:activateTab(tab) end)
end

-- function to make a gap where the tab can be dropped in
function Adjustable.TabWindow:makeSpace(myWindow, position, resetSpace)
    myWindow = myWindow or self
    position = position or #myWindow.header.windows
    if position &lt; 1 then position = 1 end
    local current_Tab = Adjustable.TabWindow.clickedTab or {}
    local total_count = #myWindow.header.windows + 1
    -- close the space if resetSpace is true
    if resetSpace then
        position = -1
        total_count = total_count -1
    end
    
    if myWindow == self and current_Tab.name and not(Adjustable.TabWindow.doubleClick) then
        total_count = total_count -1
    end
    local new_width = myWindow.get_width() / total_count
    local new_x = 0
    local counter = 1
    for k,v in ipairs(myWindow.header.windows) do
        if v ~= current_Tab.name then
            if counter == position then
                new_x = new_x + new_width
            end
            myWindow.header.windowList[v]:resize(new_width)
            myWindow.header.windowList[v]:move(new_x)   
            new_x = new_x + new_width
            counter = counter + 1  
        end
    end
end

-- function to change the parent window of the tab 
function Adjustable.TabWindow:changeTabContainer(tab, myWindow, position)
    if self ~= myWindow or self[tab].floating then
        myWindow[tab] = self[tab]
        myWindow[tab.."center"] = self[tab.."center"]
        self[tab].container = not(self[tab].floating) and self.header or Geyser 
        self[tab.."center"]:changeContainer(myWindow.footer)
        self[tab]:changeContainer(myWindow.header)
        if not (self[tab].floating) then
            self:removeTab(tab)
            self:createTabs()
        end
        myWindow:createTabs()
        myWindow[tab]:show()
        if not(myWindow.hidden or myWindow.auto_hidden) then
            myWindow:show()
        end
    end
    myWindow:addTab(tab, position)
    if self.current then
        self[self.current]:show()
    end
    if #self.tabs &gt; 0 then
        if not (self[tab].floating) then
            self:activateTab(self.tabs[1])
        end
    else 
        self.current = nil
    end
    myWindow:activateTab(tab)
end

-- handles the release event
function Adjustable.TabWindow:onRelease(tab, event, position)
    if Adjustable.TabWindow.doubleClick then
        return
    end
    local myWindow = Adjustable.TabWindow.currentWindow or self
    local floating = self[tab].floating
    if event.button == "LeftButton" and Adjustable.TabWindow.currentWindow and myWindow.type == "adjustabletabwindow" and not floating then
        self[tab]:lockContainer()
        self[tab].container = self.header
        self[tab]:onRelease(self[tab].adjLabel, event)
        self[tab].adjLabel:echo(self[tab].tabText, "nocolor", "c")
        tab_pos = tab_pos or myWindow:findPosition(self[tab])
        if myWindow ~= self then
            self:changeTabContainer(tab, myWindow)
        end  
        myWindow:addTab(tab, tab_pos)
        myWindow:raiseAll()
    end
    
    if event.button == "LeftButton" and myWindow.type == "adjustablecontainer" then
        local tabname = myWindow.tabname
        local tabwindow = Adjustable.TabWindow.allTabs[tabname]
        local mytab = tabwindow[tabname]
        local tempWindow = tabwindow:createTempWindow(mytab)
        self:changeTabContainer(tab, tempWindow.tabWindow)
        tempTimer(0, function() tempWindow.tabWindow:activateTab(tab) end)
        tempWindow:raiseAll()
        self[tab]:onRelease(self[tab].adjLabel, event)
        Adjustable.TabWindow.currentWindow = tempWindow.tabWindow
    end
    
    if event.button == "LeftButton" and not(Adjustable.TabWindow.currentWindow) and not floating then
        self:transformTabContainer(tab)
        self[tab]:onRelease(self[tab].adjLabel, event)
    end
    
    if floating then
        self[tab]:onRelease(self[tab].adjLabel, event)
    end
    
    Adjustable.TabWindow.clicked = false
    Adjustable.TabWindow.currentWindow = nil
    if not (Adjustable.TabWindow.doubleClick) then
        Adjustable.TabWindow.clickedTab = nil
    end
    tab_pos = nil
end

-- change the text a tab displays
function Adjustable.TabWindow:setTabText(which, text)
    assert(type(which) == "string" or type(which) == "number", "setTabText: bad argument #1 type (tab name/position as string or number expected, got "..type(which).."!)")
    assert(type(text) == "string", "setTabText: bad argument #2 type (tab text as string expected, got "..type(text).."!)")
    if not (type(which) == "number" and which &lt;= #self.tabs) then
        which = table.index_of(self.tabs, which)
    end
    
    if which then
        self[self.tabs[which]]:setTitle("")
        self[self.tabs[which]].titleText = "&amp;nbsp;&amp;nbsp;"..text
        self[self.tabs[which]].tabText = text
        self[self.tabs[which]].adjLabel:echo(text, "nocolor", "c")
        setTabToolTip(self[self.tabs[which]])
        return true
    end
    return nil, "setTabText: Couldn't find tab to set a new text"
end

-- removes a tab (this won't be saved)
function Adjustable.TabWindow:removeTab(which)
    assert(type(which) == "string" or type(which) == "number", "removeTab: bad argument #1 type (tab name/position as string or number expected, got "..type(which).."!)")
    local index
    if type(which) == "number" and which &lt;= #self.tabs then
        index = which
    else
        index = table.index_of(self.tabs, which)
    end
    if index then
        local tabname = self.tabs[index]
        self[tabname]:hide()
        self.header:remove(self[tabname])
        self.header:organize()
        table.remove(self.tabs, index)
        self:activateTab(self.tabs[1])
        if self.temporary then
            -- destroy empty tempTabWindow
            if table.is_empty(self.tabs) then
                self[tabname].tempWindow:changeContainer("main")
                Adjustable.TabWindow.all[self.name] = nil
                table.remove(Adjustable.TabWindow.all_windows, table.index_of(Adjustable.TabWindow.all_windows, self))
                self[tabname].tempWindow:detach()
                self[tabname].tempWindow:disconnect()
                self[tabname].tempWindow:hide()
                -- delete all references to this tab to avoid it being sent to nirwana if restored
                for k,v in pairs (Adjustable.TabWindow.allTabs) do
                    if v.name == self.name then
                        local styleOrigin = Adjustable.TabWindow.all[self.tempStyle]
                        Adjustable.TabWindow.allTabs[k] = styleOrigin
                        styleOrigin[k] = styleOrigin[k] or self[k]
                        styleOrigin[k.."center"] = styleOrigin[k.."center"] or self[k.."center"]
                        styleOrigin[k].minimizeLabel:setClickCallback(function() styleOrigin[k]:onMinimizeClick(k) end)
                        styleOrigin[k].minLabel:setClickCallback(function() styleOrigin[k]:onMinimizeClick(k) end)
                    end
                end
            end
            self[tabname].tempWindow = nil
            self[tabname].tempTabWindow = nil
        end
        return true
    end
    return nil, "removeTab: Couldn't find tab to remove"
end

-- adds a tab (this won't be saved)
function Adjustable.TabWindow:addTab(name, pos)
    assert(type(name) == "string", "addTab: bad argument #1 type (tab name as string expected, got "..type(name).."!)")
    pos = pos or #self.tabs
    pos = pos &gt; #self.tabs and #self.tabs or pos
    assert(type(pos) == "number", "addTab: bad argument #2 type (tab position as number expected, got "..type(pos).."!)")
    --check if tabName exists already
    local index = table.index_of(self.tabs, name)
    -- check if postion is valid
    if pos &lt; 1 and #self.tabs ~= 0 then
        return nil, "addTab: not a valid position"
    end
    
    pos = index and pos &gt; #self.tabs and #self.tabs or not(index) and pos == #self.tabs and pos + 1 or pos
    
    -- if tab exists and is at the same position already, do nothing
    if index == pos then
        self.header:organize()
        return true
    end
    
    -- if tab exists and position is different, then change the position
    if index then 
        table.remove(self.tabs, index)
        table.remove(self.header.windows, index)
    end
    table.insert(self.tabs, pos, name)
    
    -- if tab is new create a new Label
    if not index then
        self:createTabs()
    end
    
    --If the container isn't the right one change it (useful if removed in one adj tabwindow and added to another)
    self[name.."center"]:changeContainer(self.footer)
    self[name]:changeContainer(self.header)  
    
    local headername = self[name].name
    -- if name is already in windows delete it to put it into the right position
    local headerIndex = table.index_of(self.header.windows, headername)
    if headerIndex then
        table.remove(self.header.windows, headerIndex)
    end
    table.insert(self.header.windows, pos, headername)
    self.header.windowList[headername] = self[name]
    self[name]:show()
    self.header:organize()
    self:activateTab(name)
    if self.temporary then
        self[name].tempWindow = self.container.container
        self[name].tempTabWindow = self
    end
    
    -- put ToolTip on Label if TabText is to long to display
    setTabToolTip(self[name])
    return true
end

function Adjustable.TabWindow:addToTabWindow(container)
    local name = container.name
    self:addTab(name)
    container:detach()
    container:disconnect()
    container:changeContainer(self[name.."center"])
    container:resize("100%","100%")
    container:move(0,0)
    self[name].tabified = true
    
    if container.type == "adjustablecontainer" then
        container:lockContainer("full")
        if container.autoSave then
            container:disableAutoSave()
        end
        local titleText = string.gsub(container.titleText, "&amp;nbsp;", "")
        self:setTabText(name, titleText)
        self:createTabs()
    end
end

--transforms adjcontainer to a floating tab
function Adjustable.TabWindow:tabify(container)
    local x, y, width, height = container:get_x(), container:get_y(), container:get_width(), container:get_height()
    local parent = container.container
    self:addToTabWindow(container)
    self:transformTabContainer(container.name)
    self[container.name]:move(x,y)
    self[container.name]:resize(width,height)
    self[container.name]:changeContainer(parent)
    self:createTempWindow(self[container.name])
end

function Adjustable.TabWindow:addTabifyMenu(adjcontainer)
    if adjcontainer.type ~= "adjustablecontainer" then
        return "not an adjustable container"
    end
    adjcontainer:newCustomItem("Tabify", function() self:tabify(adjcontainer) end)
end

--- saves your container settings
-- like tab position and some other variables in your Mudlet Profile Dir/ Adjustable.TabWindow
-- to be reliable it is important that every Adjustable.TabWindow has an unique 'name'
-- @see Adjustable.TabWindow:load
function Adjustable.TabWindow:save(slot, dir)
    if type(self) ~= "table" then
        dir = slot
        slot = self
    end
    assert(slot == nil or type(slot) == "string" or type(slot) == "number", "Adjustable.TabWindow.save: bad argument #1 type (slot as string or number expected, got "..type(slot).."!)")
    assert(dir == nil or type(dir) == "string" , "Adjustable.TabWindow.save: bad argument #2 type (directory as string expected, got "..type(dir).."!)")
    
    dir = dir or self.defaultDir
    slot = slot or ""
    local saveDir = string.format("%s%s%s.lua", dir, "TabWindowTabs", slot)
    
    local mytable = {}
    -- save fixed tabs
    for k,v in pairs(Adjustable.TabWindow.all) do
        mytable[k] = {}
        mytable[k].tabs = v.tabs
        mytable[k].current = v.current
        mytable[k].temporary = v.temporary
    end
    -- save floating tabs, tempTabWindows and tabified containers
    for k,v in pairs(Adjustable.TabWindow.allTabs) do
        
        --floating tabs
        if v[k].floating then
            -- save the tabs adjustable container settings
            v[k]:save(slot, dir)
            -- get all floating tabs and their windownames
            mytable[v.name].floatingTabs = mytable[v.name].floatingTabs or {}
            mytable[v.name].floatingTabs[k] = "main"
            if v[k].windowname ~= "main" then
                mytable[v.name].floatingTabs[k] = v[k].windowname
            end
        end
        
        --tempTabWindows
        if v[k].tempWindow then
            --save tempWindow adjustable container settings
            v[k].tempWindow:save(slot, dir)
            mytable[v.name].windowname = v[k].tempWindow.windowname
            --save window where tempStyle came from
            mytable[v.name].tempStyle = v[k].tempTabWindow.tempStyle
        end
        
        --tabified containers
        if v[k].tabified then
            mytable.tabifiedContainers = mytable.tabifiedContainers or {}
            mytable.tabifiedContainers[#mytable.tabifiedContainers + 1] = k
        end
    end
    
    if not(io.exists(dir)) then lfs.mkdir(dir) end
    table.save(saveDir, mytable)
end


--- restores/loads the before saved settings 
-- it is very important to load after all TabWindows are created
-- @see Adjustable.TabWindow:save
function Adjustable.TabWindow:load(slot, dir)
    if type(self) ~= "table" then
        dir = slot
        slot = self
    end
    assert(slot == nil or type(slot) == "string" or type(slot) == "number", "Adjustable.TabWindow.load: bad argument #1 type (slot as string or number expected, got "..type(slot).."!)")
    assert(dir == nil or type(dir) == "string" , "Adjustable.TabWindow.load: bad argument #2 type (directory as string expected, got "..type(dir).."!)")
    dir = dir or self.defaultDir
    local slot = slot or ""
    local loadDir = string.format("%s%s%s.lua", dir, "TabWindowTabs", slot)
    local mytable = {}
    if io.exists(loadDir) then
        table.load(loadDir, mytable)
    else
        return "No saved settings found at: "..loadDir
    end
    
    -- find the tabified container by name
    local function findWindow(cont, name)
        cont = cont or Geyser
        for k, v in pairs(cont.windowList) do
            if name == v.name then
                return v
            end
            if findWindow(v, name) then
                return findWindow(v, name)
            end
        end
    end
    
    -- create Tabified Windows
    if mytable.tabifiedContainers then 
        for k,v in ipairs (mytable.tabifiedContainers) do
            local container = findWindow(nil, v)
            if not (Adjustable.TabWindow.allTabs[v]) then 
                Adjustable.TabWindow.all[Adjustable.TabWindow.all_windows[1]]:addToTabWindow(container)
            end
        end
        mytable.tabifiedContainers = nil
    end
    -- create TempWindows and TempTabWindows
    for k,v in pairs (mytable) do
        if v.temporary then
            if not Adjustable.TabWindow.all[k] then
                local tempStyleWindow = Adjustable.TabWindow.all[v.tempStyle]
                tempStyleWindow:createTempWindow(nil, k)
            end
            Adjustable.TabWindow.all[k].container.container:load(slot, dir)
            if v.windowname ~= "main" then
                Adjustable.TabWindow.all[k].container.container:changeContainer(Geyser.windowList[v.windowname.."Container"].windowList[v.windowname])
            end
        end
    end
    
    
    for k,v in pairs(mytable) do
        -- load fixed Tabs
        local myWindow = Adjustable.TabWindow.all[k]
        for k1,v1 in ipairs(v.tabs) do
            local myTabWindow = Adjustable.TabWindow.allTabs[v1]
            if myTabWindow then
                local myTab = myTabWindow[v1]
                if myTab.floating then
                    myTabWindow:restoreTab(v1)
                end
                if not myWindow.header.windowList[v1] then
                    myTabWindow:changeTabContainer(v1, myWindow)
                end
                myWindow:addTab(v1,k1)
            end
        end
        if myWindow then
            myWindow:deactivateTab()
            myWindow.current = v.current
            tempTimer(0, function() myWindow:activateTab(v.current) end)
            myWindow:raiseAll() 
        end
        -- load floating Tabs
        if v.floatingTabs then
            for k1, v1 in pairs(v.floatingTabs) do
                local myTabWindow = Adjustable.TabWindow.allTabs[k1]
                local styleTabWindow = Adjustable.TabWindow.all[k]
                if myTabWindow and styleTabWindow  then
                    local myTab = myTabWindow[k1]
                    if myTabWindow ~= styleTabWindow then
                      myTabWindow:changeTabContainer(k1, styleTabWindow)
                      myTabWindow = styleTabWindow
                    end
                    myTabWindow:transformTabContainer(k1)
                    -- send my Tab to a UserWindow if saved there
                    if v1 ~= "main" then
                        myTab:changeContainer(Geyser.windowList[v1.."Container"].windowList[v1])
                    end
                    -- load Adjustable Container settings
                    myTab:load(slot, dir)
                end
            end
        end        
    end
end

-- EMCO by demonnic https://github.com/demonnic/EMCO
function Adjustable.TabWindow:transferEMCO(emco)
    local EMCO = EMCO or require("MDK-1.EMCO")
    emco:hide()
    local emco_tabs = emco.tabs
    local emco_tabwindows = emco.consoles
    local emco_windows = emco.mc
    
    -- xEcho override
    local myXEcho = 
    function(s, tabName, message, xtype, excludeAll)
        s.currentTab = self.current        
        if s.blink and tabName ~= s.currentTab then
            if not (s.allTabName == s.currentTab and not s.blinkFromAll) then
                s.tabsToBlink[tabName] = true
            end
        end   
        EMCO.xEcho(s, tabName, message, xtype, excludeAll)
    end
    
    -- Flash override
    local myFlash = 
    function(s)
        Geyser.Container.flash(s) 
        raiseWindow(s.name .."_dimensions_flash")
    end
    -- doBlink override
    local myDoBlink =
    function(s)
        s.currentTab = self.current
        if s.blink then
            if s.allTab and not s.blinkFromAll and (s.currentTab == s.allTabName or self[s.allTabName.."center"].hidden == false) then
                s.tabsToBlink = {}
            elseif s.tabsToBlink[s.currentTab] then
                s.tabsToBlink[s.currentTab] = nil
            end
        end    
        for tab,_ in pairs(s.tabsToBlink) do
            if not self[tab].floating and self[tab.."center"].hidden then
                s.tabs[tab]:flash()
            else
                s.tabsToBlink[tab] = nil
            end
        end
    end
    
    --function for transfering tab and console
    local function transferTab(tabwindow)
        emco_windows[tabwindow]:show()
        emco_windows[tabwindow]:changeContainer(self[tabwindow.."center"])
        emco_tabs[tabwindow]:changeContainer(self[tabwindow])
        emco_tabs[tabwindow]:move(0,0)
        emco_tabs[tabwindow]:resize("100%","100%")
        emco_tabs[tabwindow]:hide()
        emco_tabs[tabwindow].flash = myFlash
        if emco_tabs[tabwindow].font then
            self[tabwindow].adjLabel:setFont(emco_tabs[tabwindow].font)
        end  
    end
    
    --addTab override
    local myAddTab =
    function(s, tabName, position)
        EMCO.addTab(s, tabName)
        self:addTab(tabName, position)
        transferTab(tabName)
        self:activateTab(tabName)
    end
    
    --removeTab override
    local myRemoveTab =
    function(s, tabName)
        EMCO.removeTab(s, tabName)
        if self[tabName].floating then
            self:restoreTab(tabName)
        end
        Adjustable.TabWindow.allTabs[tabName]:removeTab(tabName)
    end
    
    --transfering process
    self.tabs = table.n_union(self.tabs, emco_tabwindows)
    self:createTabs()
    for k,v in ipairs(emco_tabwindows) do
        transferTab(v)
    end
    self:activateTab(emco.currentTab)
    emco.reset = function() end
    emco.removeTab = myRemoveTab
    emco.addTab = myAddTab
    emco.xEcho = myXEcho
    emco.doBlink = myDoBlink
    emco.setGap = function(s, gap) EMCO.setGap(s, gap) self:setGap(math.max(2,gap) -2) end
    emco.setTabHeight = function(s, height) EMCO.setTabHeight(s, height) self:setTabHeight(height+2) end
    emco.setTabBoxColor = function(s, color) EMCO.setTabBarColor(s, color) self:setTabBarColor(color) end
    emco.setTabBoxCSS = function(s, css) EMCO.setTabBoxCSS(s, css) self:setTabBarCSS(css) end
    emco.setActiveTabBGColor = function(s, color) self:setActiveTabBGColor(color) EMCO.setActiveTabBGColor(s, color) end
    emco.setInactiveTabBGColor = function(s, color) self:setInactiveTabBGColor(color) EMCO.setInactiveTabBGColor(s, color) end
    emco.setActiveTabFGColor = function(s, color) EMCO.setActiveTabFGColor(s, color) self:setActiveTabFGColor(color) end
    emco.setInactiveTabFGColor = function(s, color) EMCO.setInactiveTabFGColor(s, color) self:setInactiveTabFGColor(color) end
    emco.setSingleTabFont = function(s, tab, font) EMCO.setSingleTabFont(s, tab, font) self:setSingleTabFont(tab, font) end
    emco.setTabFont = function(s, font) EMCO.setTabFont(s, font) self:setTabFont(font) end
    emco.save = function(s, slot, dir) EMCO.save(s) self:save(slot, dir) end
    emco.load = function(s, slot, dir) EMCO.load(s) self:load(slot, dir) end
end

-- EMCO by demonnic https://github.com/demonnic/EMCO
-- convert EMCO to Adjustable TabWindow
function Adjustable.TabWindow.convertEMCO(emco)
    if emco.myTabWindow then
        return
    end
    emco.myTabWindow = emco.myTabWindow or Adjustable.TabWindow:new({
        name = emco.name.."TabWindow", 
        x = emco.x, 
        y = emco.y, 
        width = emco.width, 
        height = emco.height,
        centerStyle = "background-color: rgba(0,0,0,0);",
        footerStyle = "background-color: rgba(0,0,0,0);",
        activeTabStyle = emco.activeTabCSS,
        inactiveTabStyle = emco.inactiveTabCSS,
        tabBarHeight  = emco.tabHeight + 2,
        gap = emco.gap - 2,
    },emco.container)
    emco.myTabWindow:setActiveTabFGColor(emco.activeTabFGColor)
    emco.myTabWindow:setInactiveTabFGColor(emco.inactiveTabFGColor)
    emco.myTabWindow:setActiveTabBGColor(emco.activeTabBGColor)
    emco.myTabWindow:setInactiveTabBGColor(emco.inactiveTabBGColor)
    emco.myTabWindow:transferEMCO(emco)
    emco.hide = function() Geyser.Container.hide(emco.myTabWindow) end
    emco.show = function() Geyser.Container.show(emco.myTabWindow) end
    emco:show()
end

-- Save a reference to our parent constructor
Adjustable.TabWindow.parent = Geyser.Container
-- Create table to put every Adjustable.TabWindow in it
Adjustable.TabWindow.all = Adjustable.TabWindow.all or {}
Adjustable.TabWindow.all_windows = Adjustable.TabWindow.all_windows or {}
Adjustable.TabWindow.allTabs = Adjustable.TabWindow.allTabs or {}

-- tabwindow constructor
function Adjustable.TabWindow:new(cons, container)
    Geyser.HBox.organize = Geyser.HBox.organize or Geyser.HBox.reposition
    local me = self.parent:new(cons, container)
    cons = cons or {}
    setmetatable(me, self)
    self.__index = self
    me.type = "adjustabletabwindow"
    me.defaultDir = me.defaultDir or getMudletHomeDir().."/AdjustableTabWindow/"
    me.tabs = me.tabs or {}
    me.tabTxtColor = me.tabTxtColor or "white"
    me.tabPadding = me.tabPadding or 12
    me.color1 = me.color1 or "rgb(0,0,100)"
    me.color2 = me.color2 or "rgb(0,0,70)"
    me.activeTabBGColor = me.activeTabBGColor or me.color1
    me.inactiveTabBGColor = me.inactiveTabBGColor or me.color2
    me.tabBarHeight = me.tabBarHeight or "35"
    me.gap = me.gap or 0
    me.footerStyle = me.footerStyle or [[
    background-color: ]]..me.color1..[[;
    border-bottom-left-radius: 10px;
    border-bottom-right-radius: 10px;
    ]]
    
    me.centerStyle = me.centerStyle or [[
    background-color: ]]..me.color2..[[;
    border-radius: 10px;
    margin: 5px;
    ]]
    
    me.inactiveTabStyle = me.inactiveTabStyle or [[QLabel::hover{
        background-color: ]]..me.activeTabBGColor..[[;
        color: ]]..me.tabTxtColor..[[;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        margin-right: 1px;
        margin-left: 1px;
        qproperty-alignment: 'AlignVCenter';
    }
    QLabel::!hover{
        background-color: ]]..me.inactiveTabBGColor..[[;
        color: ]]..me.tabTxtColor..[[;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        margin-right: 1px;
        margin-left: 1px;
        qproperty-alignment: 'AlignVCenter';
    }
    ]]
    
    me.activeTabStyle = me.activeTabStyle or [[
    background-color: ]]..me.activeTabBGColor..[[;
    color: ]]..me.tabTxtColor..[[;
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    margin-right: 1px;
    margin-left: 1px;
    qproperty-alignment: 'AlignVCenter';
    ]]
    
    me.chosenTabStyle = me.chosenTabStyle or [[
    background-color: rgba(255,30,0,60%);
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    margin-right: 1px;
    margin-left: 1px;
    color: ]]..me.tabTxtColor..[[;
    
    ]]
    
    
    me.overlayStyle = me.overlayStyle or [[
    background-color: rgba(0,0,0,0%);
    border: 2px solid white;]]
    
    me.tabBarStyle = me.tabBarStyle or [[
    background-color: rgba(0,0,0,0%);
    ]]
    
    me.tempWindowConf = me.tempWindowConf or 
    {
        buttonsize = "12",
        buttonFontSize = "7",
        padding = 9,
        buttonstyle = [[
        QLabel{ border-radius: 4px; background-color: rgba(80,80,80,80%);}
        QLabel::hover{ background-color: rgba(60,60,60,50%);}
        ]],
        adjLabelstyle = [[background-color: rgba(0,0,0,90%); border: 2px solid rgb(50,50,50);]]
    }
    
    me:createBaseContainers()
    me:createTabs()
    
    if me.tabBarColor then 
        me:setTabBarColor(me.tabBarColor)
    else
        me.tabBarColor = "black"
    end
    
    local found = string.match(" "..me.activeTabStyle, "(%scolor:).-(;)")
    if not(found) then
        me.activeTabFGColor = me.activeTabFGColor or me.tabTxtColor
    end
    
    found = string.match(" "..me.inactiveTabStyle, "(%scolor:).-(;)")
    if not(found) then
        me.inactiveTabFGColor = me.inactiveTabFGColor or me.tabTxtColor
    end
    
    if me.activeTabFGColor then 
        me:setActiveTabFGColor(me.activeTabFGColor)
    end
    if me.inactiveTabFGColor then
        me:setInactiveTabFGColor(me.inactiveTabFGColor)
    end
    
    me.current = me.current or me.tabs[#me.tabs]
    
    if me.tabs[1] then
        me:activateTab(me.tabs[1])
    end
    tempTimer(0, 
    function()
        local tabNr = #me.tabs 
        if me.tabs[1] and tabNr &gt; 1 then 
            me[me.tabs[tabNr].."center"]:hide()
        end 
    end )
    
    if not Adjustable.TabWindow.all[me.name] then
        Adjustable.TabWindow.all_windows[#Adjustable.TabWindow.all_windows + 1] = me.name
    end
    Adjustable.TabWindow.all[me.name] = me
    
    return me
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Gooey Variables</name>
				<packageName></packageName>
				<script>gooey = gooey or {}

gooey.gui = gooey.gui or {} --gui elements, containers and crap
gooey.vars = gooey.vars or {} --variables
gooey.funcs = gooey.funcs or {} --functions
gooey.data = gooey.data or {} --tables
gooey.triggers = gooey.triggers or {} --triggers
gooey.timers = gooey.timers or {} --triggers

-- Built-in modules:
----sea
----hunt
----combat
----serverSettings --stores personal server-side settings, command separator, pagelength, curing
----gmcp --info from GMCP

gooey.gui.styles = gooey.gui.styles or {}
gooey.gui.fontSize = gooey.gui.fontSize or {}
gooey.gui.var = gooey.gui.fontSize or {}

gooey.vars.sea = gooey.vars.sea or {}
gooey.vars.hunt = gooey.vars.hunt or {}
gooey.vars.combat = gooey.vars.combat or {}
gooey.vars.serverSettings = gooey.vars.serverSettings or {}
gooey.vars.gmcp = gooey.vars.gmcp or {}
  gooey.vars.gmcp.old = gooey.vars.gmcp.old or {}
gooey.vars.gui = gooey.vars.gui or {}


gooey.funcs.sea = gooey.funcs.sea or {}
gooey.funcs.hunt = gooey.funcs.hunt or {}
gooey.funcs.combat = gooey.funcs.combat or {}
gooey.funcs.serverSettings = gooey.funcs.serverSettings or {} 
gooey.funcs.gmcp = gooey.funcs.gmcp or {}

gooey.data.sea = gooey.data.sea or {}
gooey.data.hunt = gooey.data.hunt or {}
gooey.data.combat = gooey.data.combat or {}
gooey.data.serverSettings = gooey.data.serverSettings or {} 
gooey.data.gmcp = gooey.data.gmcp or {} 

gooey.triggers.sea = gooey.triggers.sea or {}
gooey.triggers.hunt = gooey.triggers.hunt or {}
gooey.triggers.combat = gooey.triggers.combat or {}
gooey.triggers.serverSettings = gooey.triggers.serverSettings or {}
gooey.triggers.gmcp = gooey.triggers.gmcp or {}


--adjust fonts here
gooey.gui.fontSize.peopleConsole = 9
gooey.gui.fontSize.topright = 9
gooey.gui.fontSize.bottomleft = 9
gooey.gui.fontSize.people = 9
gooey.gui.fontSize.midleft = 9
gooey.gui.fontSize.topleft = 9
gooey.gui.fontSize.bottom = 9
gooey.gui.fontSize.top = 9
gooey.gui.fontSize.bottomright = 9
gooey.gui.fontSize.denizens = 9
gooey.gui.fontSize.denizensConsole = 9

--determines if the players and the items consoles are one next to the other or one above the other. Options are "vertical" or "horizontal"
gooey.gui.preferedRoomLayout = gooey.gui.preferedRoomLayout or "horizontal" 


--define some styles 
gooey.gui.styles = {
basic = { adjLabel = "background-color:rgba(20,20,20,100%); border: 2px inset dimgray; border-color: rgba(128, 128, 128, 100%);", 
          buttonstyle = [[QLabel{ background-color: rgba(20,20,20,100%);}
                        QLabel::hover{ background-color: rgba(160,160,160,50%); border-color: rgba(102, 102, 102, 1);} ]],
        },
basic2 = { adjLabel = "background-color:rgba(51, 51, 51, 1); border: 2px inset dimgray; border-color: rgba(85, 85, 85, 1); color: rgba(204, 204, 204, 1);",
          buttonstyle = [[QLabel{ background-color: rgba(51, 51, 51, 1);border-color: rgba(85, 85, 85, 1); color:rgba(204, 204, 204, 1) }
                        QLabel::hover{background-color: rgba(68, 68, 68, 1); border-color: rgba(102, 102, 102, 1);} ]]
        }
}

--change this to your prefered style
gooey.gui.myStyle = "basic"

</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Build Main</name>
				<packageName></packageName>
				<script>local myadjlabel = gooey.gui.styles[gooey.gui.myStyle].adjLabel
local mybuttonstyle = gooey.gui.styles[gooey.gui.myStyle].buttonstyle

gooey.moduleHome = string.split(getModulePath("gooey"), "gooey.*%.xml")[1]

--main skeleton
gooey.gui.top = gooey.gui.top or Adjustable.Container:new({
  name = "top", y="0%", height = "15%", 
  buttonFontSize = 7, buttonsize = 10, padding = 6, 
  adjLabelstyle = myadjlabel, buttonstyle = mybuttonstyle, })
gooey.gui.bottom = gooey.gui.bottom or Adjustable.Container:new({
  name = "bottom", height = "15%", y = "-10%", 
  buttonFontSize = 7, buttonsize = 10, padding = 6, 
  adjLabelstyle = myadjlabel, buttonstyle = mybuttonstyle,})

gooey.gui.topright = gooey.gui.topright or Adjustable.Container:new({
  name = "topright", y = "0%", height = "50%", x = "-30%", width = "30%", 
  buttonFontSize = 7, buttonsize = 10, padding = 6, 
  adjLabelstyle = myadjlabel, buttonstyle = mybuttonstyle, })
gooey.gui.bottomright = gooey.gui.bottomright or Adjustable.Container:new({
  name = "bottomright", y = "50%", height = "50%", x = "-30%", width = "30%", 
  buttonFontSize = 7, buttonsize = 10, padding = 6, 
  adjLabelstyle = myadjlabel, buttonstyle = mybuttonstyle,})
gooey.gui.topleft = gooey.gui.topleft or Adjustable.Container:new({
  name = "topleft", x = "0%", y = "0%", height = "33%", width = "20%", 
  buttonFontSize = 7, buttonsize = 10, padding = 6, 
  adjLabelstyle = myadjlabel, buttonstyle = mybuttonstyle,})
gooey.gui.midleft = gooey.gui.midleft or Adjustable.Container:new({
  name = "midleft", x = "0%", y = "33%", eight = "33%", width = "20%", 
  buttonFontSize = 7, buttonsize = 10, padding = 6,
  adjLabelstyle = myadjlabel, buttonstyle = mybuttonstyle, })
gooey.gui.bottomleft = gooey.gui.bottomleft or Adjustable.Container:new({
  name = "bottomleft", x = "0%", y = "66%", height = "34%", width = "20%", 
  buttonFontSize = 7, buttonsize = 10, padding = 6, 
  adjLabelstyle = myadjlabel, buttonstyle = mybuttonstyle, })


gooey.gui.top:attachToBorder("top")
gooey.gui.bottom:attachToBorder("bottom")

gooey.gui.topright:attachToBorder("right")
gooey.gui.bottomright:attachToBorder("right")

gooey.gui.topleft:attachToBorder("left")
gooey.gui.midleft:attachToBorder("left")
gooey.gui.bottomleft:attachToBorder("left")

gooey.gui.top:connectToBorder("left")
gooey.gui.top:connectToBorder("right")
gooey.gui.bottom:connectToBorder("left")
gooey.gui.bottom:connectToBorder("right")

gooey.gui.topleft:connectToBorder("left")
gooey.gui.midleft:connectToBorder("left")
gooey.gui.bottomleft:connectToBorder("left")
gooey.gui.topright:connectToBorder("right")
gooey.gui.bottomright:connectToBorder("right")
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Room Build</name>
					<packageName></packageName>
					<script>local myadjlabel = gooey.gui.styles[gooey.gui.myStyle].adjLabel
local mybuttonstyle = gooey.gui.styles[gooey.gui.myStyle].buttonstyle


--room info - VBox to separate the room name console from the denizens and people consoles
gooey.gui.roomVBox = gooey.gui.roomVBox or Geyser.VBox:new({
  name="roomVBox", x = 0, y = 0, width = "100%", height = "100%"}, gooey.gui.topleft)

gooey.gui.roomNameLabel = gooey.gui.roomNameLabel or 
    Geyser.Label:new({name = "roomNameLabel", x = "0%", y="0%", height = "12%", width = "100%", 
    color = "black", v_policy=Geyser.Fixed }, 
      gooey.gui.roomVBox )

gooey.gui.roomNameLabel: setStyleSheet( [[background-color:rgba(20,20,20,100%); border: 2px inset; border-color:rgba(128, 128, 128, 100%);]])

if gooey.vars.gmcp and gooey.vars.gmcp.roomname then gooey.gui.roomNameLabel:echo(gooey.vars.gmcp.roomname, "ansiYellow", "c13") end
    

if gooey.gui.preferedRoomLayout == "horizontal" then
  gooey.gui.roomRoomBox = gooey.gui.roomRoomBox or Geyser.HBox:new({
  name="roomRoomBox", x = 0, y = 0, width = "100%", height = "90%"}, 
   gooey.gui.roomVBox)
  
  gooey.gui.denizens = gooey.gui.denizens or 
    Adjustable.Container:new({
      name = "denizens", y = 0, x = "0%", width = "75%", height = "100%",
      buttonFontSize = 7, buttonsize = 10, h_policy = Geyser.Fixed, 
      adjLabelstyle = myadjlabel, buttonstyle = mybuttonstyle,}, 
        gooey.gui.roomRoomBox)
  gooey.gui.people = gooey.gui.people or 
    Adjustable.Container:new({
      name = "people", y = 0, x = "0%", width = "25%", height = "100%",
      buttonFontSize = 7, buttonsize = 10, h_policy = Geyser.Fixed, 
      adjLabelstyle = myadjlabel, buttonstyle = mybuttonstyle,}, 
        gooey.gui.roomRoomBox)

elseif gooey.gui.preferedRoomLayout == "vertical" then
  gooey.gui.roomRoomBox = gooey.gui.roomRoomBox or Geyser.VBox:new({
    name="roomRoomBox", x = 0, y = 0, width = "100%", height = "90%"}, 
      gooey.gui.roomVBox)
  
  gooey.gui.denizens = gooey.gui.denizens or 
    Adjustable.Container:new({name = "denizens", y = "0%", x = 0, height = "65%", width = "100%", 
    buttonFontSize = 7, buttonsize = 10, v_policy=Geyser.Fixed, 
    adjLabelstyle = myadjlabel, buttonstyle = mybuttonstyle,}, 
      gooey.gui.roomRoomBox)
      
  gooey.gui.people = gooey.gui.people or 
    Adjustable.Container:new({name = "people", y = "35%" , x = 0, height = "35%", width = "100%", 
    buttonFontSize = 7, buttonsize = 10, v_policy=Geyser.Fixed, 
    adjLabelstyle = myadjlabel, buttonstyle = mybuttonstyle,}, 
      gooey.gui.roomRoomBox)


end

gooey.gui.denizensConsole = gooey.gui.denizensConsole or 
    Geyser.MiniConsole:new({name = "denizensConsole", x = "0%", y="0%", height = "100%", width = "100%", 
    color = "black", autoWrap = true, padding = 3}, 
      gooey.gui.denizens )
gooey.gui.peopleConsole = gooey.gui.peopleConsole or 
    Geyser.MiniConsole:new({name = "peopleConsole", x = "0%", y="0%", height = "100%", width = "100%", 
    color = "black", autoWrap = true, padding = 3}, 
      gooey.gui.people )
    </script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Mid Left Build</name>
					<packageName></packageName>
					<script>local myadjlabel = gooey.gui.styles[gooey.gui.myStyle].adjLabel
local mybuttonstyle = gooey.gui.styles[gooey.gui.myStyle].buttonstyle


gooey.gui.activityStatusContainer = gooey.gui.activityStatusContainer or 
  Adjustable.Container:new({
    name = "gooey.gui.activityStatusContainer", y = 0, x = "0%", height = "100%", width = "100%", 
    buttonFontSize = 7, buttonsize = 10, padding = 6, 
    adjLabelstyle = myadjlabel, buttonstyle = mybuttonstyle,}, 
      gooey.gui.midleft)
      
gooey.gui.activityStatusConsole = gooey.gui.activityStatusConsole or 
    Geyser.MiniConsole:new({name = "gooey.gui.activityStatusConsole", x = "0%", y="0%", height = "100%", width = "100%", 
    color = "black", autoWrap = true, padding = 3}, 
      gooey.gui.activityStatusContainer ) 
      
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Map build</name>
					<packageName></packageName>
					<script>local myadjlabel = gooey.gui.styles[gooey.gui.myStyle].adjLabel
local mybuttonstyle = gooey.gui.styles[gooey.gui.myStyle].buttonstyle

gooey.gui.map = gooey.gui.map or {}
gooey.gui.map.current = "Mapper"


gooey.gui.map.container = gooey.gui.map.container or 
  Adjustable.Container:new({
    name = "gooey.gui.map.container", y = 0, x = "0%", height = "100%", width = "100%", 
    buttonFontSize = 7, buttonsize = 10, 
    adjLabelstyle = myadjlabel, buttonstyle = mybuttonstyle,}, 
      gooey.gui.bottomleft)
      
gooey.gui.map.Mapper = gooey.gui.map.Mapper or 
  Geyser.Mapper:new({x = 0, y = 0, width = "100%", height = "100%", name="Mapper"}, gooey.gui.map.container)
showWindow("Mapper")

gooey.gui.map.Ocean = Geyser.MiniConsole:new({
    name = "Ocean",
    x = 0, y = 0,
    width = "100%",
    height = "100%",
  },gooey.gui.map.container)  
--setBackgroundColor("Ocean", 0,0,0,255)
hideWindow("Ocean")
setConsoleBufferSize("Ocean", 100, 1000) 
  
gooey.gui.map.Wilderness = Geyser.MiniConsole:new({
    name = "Wilderness",
    x = 0, y = 0,
    width = "100%",
    height = "100%",
  },gooey.gui.map.container)  
--setBackgroundColor("Wilderness", 0,0,0,255)  
hideWindow("Wilderness")
  
</script>
					<eventHandlerList />
				</Script>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Track server stuff core</name>
				<packageName></packageName>
				<script>local gfs = gooey.funcs.serverSettings
local gfg = gooey.funcs.gmcp

--Function to pick up the server-side command separator, config pagelength, and curing settings
function gfs.getServerSettings(forced) 
  if not forced then
    if not gooey.vars.serverSettings.comsep then
      tempTrigger("You can set a separator to be able to send multiple commands to Achaea at once.", [[deleteLine()]], 1)
      send("config commandseparator", false)
    end
    if not gooey.vars.serverSettings.pagelength then
      tempRegexTrigger("^Pagelength is the maximum number of lines that will be displayed to you at once.*", [[deleteLine()]], 1)
      tempTrigger("Usage:", [[deleteLine()]], 1)
      tempTrigger("   CONFIG PAGELENGTH &lt;# of lines&gt;", [[deleteLine()]], 1)
      tempLineTrigger(1, 3, [[if isPrompt() then deleteLine() end]])
      send("config pagelength", false)
    end
    if not gooey.vars.serverSettings.siphealth or not gooey.vars.serverSettings.sipmana then
      enableTrigger("getcuringinfo")
      send("curing status", false) 
    end
  end
  local gts = gooey.triggers.serverSettings
  local gvs = gooey.vars.serverSettings
  gts.curingTrigger = gts.curingTrigger or
  tempRegexTrigger("^Curing (disabled|activated)\.$", [[gooey.vars.serverSettings.curingEnabled = (matches[2] == "activated" and "Yes" or "No")]])
  gts.comSepTrigger = gts.comSepTrigger or
  tempRegexTrigger("^Your current separator is: (.*)$", [[gooey.vars.serverSettings.comsep = matches[2] ]])
  gts.pageLengthTrigger = gts.pageLengthTrigger or
  tempRegexTrigger("^Your current pagelength: (.*)$", [[if gooey.vars.serverSettings.pagelength and gooey.vars.serverSettings.pagelength ~= matches[2] then gooey.vars.serverSettings.oldpagelentgh = gooey.vars.serverSettings.pagelength end gooey.vars.serverSettings.pagelength = matches[2] ]])
  
end

--gotta delay the getServerSettings cause otherwise it'll spam like a bitch
function gfs.delayGettingInfo()
  if not gooey.vars.alreadyGettingInfoCalmDown then
    gooey.vars.alreadyGettingInfoCalmDown = true
    tempTimer(5, [[gooey.funcs.serverSettings.getServerSettings()]])
  end
end

registerAnonymousEventHandler("gmcp.Char", "gooey.funcs.serverSettings.delayGettingInfo")

--Function that gets info about the player from gmcp
function gfg.char()
  if gmcp.Char and gmcp.Char.Vitals then
    for k, v in pairs (gmcp.Char.Vitals) do
      if k == "charstats" then
        gooey.vars.gmcp.bleed = tonumber(string.split(v[1], ":")[2])
        gooey.vars.gmcp.rage = tonumber(string.split(v[2], ":")[2])
      elseif k ~= "string" then
        if gooey.vars.gmcp[k] and gooey.vars.gmcp[k] ~= tonumber(v) then
          gooey.vars.gmcp.old[k] = gooey.vars.gmcp[k]
        end
        gooey.vars.gmcp[k] = tonumber(v)
      end
    end
  end 
  if gmcp.Char and gmcp.Char.Status then
    for k, v in pairs(gmcp.Char.Status) do
      if k == "name" then 
        k = "charname"
      end
      if gooey.vars.gmcp[k] and gooey.vars.gmcp[k] ~= v then
        gooey.vars.gmcp.old[k] = gooey.vars.gmcp[k]
      end
      gooey.vars.gmcp[k] = v
    end
  end 
end

registerAnonymousEventHandler("gmcp.Char", "gooey.funcs.gmcp.char")

--Function that tracks information about the room
function gfg.room()
  gooey.vars.gmcp = gooey.vars.gmcp or {}
  gooey.vars.gmcp.old = gooey.vars.gmcp.old or {}
  
  if gmcp.Room and gmcp.Room.Info then
    for k, v in pairs(gmcp.Room.Info) do
      if table.contains({"area", "name", "num"}, k) then
        if k == "name" then 
          k = "roomname"
          if gooey.gui then 
            gooey.gui.roomNameLabel:echo(gooey.vars.gmcp.roomname, "ansiYellow", "c13") 
          end
        end
        if gooey.vars.gmcp[k] and gooey.vars.gmcp[k] ~= v then
          gooey.vars.gmcp.old[k] = gooey.vars.gmcp[k]
        end
        gooey.vars.gmcp[k] = v
      end
    end
  end
end

registerAnonymousEventHandler("gmcp.Room", "gooey.funcs.gmcp.room")

--Function to get the suff in the room
function gfg.itemsList()
  gooey.vars.gmcp.denizens = gooey.vars.gmcp.denizens or {}
  gooey.vars.gmcp.items = gooey.vars.gmcp.items or {}
  
  if gmcp and gmcp.Char and gmcp.Char.Items then
  	if gmcp.Char.Items.List.location == "room" then
  		gooey.data.gmcp.items = {} 
      gooey.data.gmcp.denizens = {}
      for k, v in pairs(gmcp.Char.Items.List.items) do
        if v.attrib =="m" then
          gooey.data.gmcp.denizens[v.id] = v.name
          if gooey.dendb then gooey.dendb.managedb(v.name) end
        else
          gooey.data.gmcp.items[v.id] = {v.name, v.attrib or ""}
        end
      end
    gooey.funcs.gmcp.displayItems()
    end
  end
end

--Funtion to handle item addition
function gfg.addItems()
  if gmcp.Char.Items.Add.location == "room" then
		local value = gmcp.Char.Items.Add.item
	  if value.attrib == "m" then
	    gooey.data.gmcp.denizens[gmcp.Char.Items.Add.item.id] = gmcp.Char.Items.Add.item.name
      if gooey.dendb then 
        gooey.dendb.managedb(gmcp.Char.Items.Add.item.name) 
      end
    else
      gooey.data.gmcp.items[gmcp.Char.Items.Add.item.id] = {gmcp.Char.Items.Add.item.name, gmcp.Char.Items.Add.item.attrib or ""}
    end
    gooey.funcs.gmcp.displayItems()
	end
end

--Function to handle item removal
function gfg.removeItems()
	if gmcp.Char.Items.Remove.location == "room" then
    if gmcp.Char.Items.Remove.item.attrib and gmcp.Char.Items.Remove.item.attrib == "m" then
      gooey.data.gmcp.denizens[gmcp.Char.Items.Remove.item.id] = nil
      if gooey.dendb then 
        gooey.dendb.managedb(gmcp.Char.Items.Remove.item.name) 
      end
    else
      gooey.data.gmcp.items[gmcp.Char.Items.Remove.item.id] = nil
  	end
  gooey.funcs.gmcp.displayItems()
  end
end

--Function to display items in the room 
function gfg.displayItems()
  local console = "denizensConsole"
  local gv = gooey.vars
  --window, text, command, hint, true
  
  clearWindow(console)
  
  --if we're on a ship, we want weapons first
  local function getWeapons(key, value)
    if string.find(value[1], "ballista") or 
       string.find(value[1], "thrower") or
       string.find(value[1], "onager") 
    then return true
    end
  end
  
  local weapons = table.collect(gooey.data.gmcp.items, getWeapons) 
  
  if gooey.vars.sea.shipOn then
    cechoLink(console,"&lt;DarkSlateGray&gt;[&lt;SteelBlue&gt;"..((gv.expandWeap and "-") or "+").."&lt;DarkSlateGray&gt;] &lt;SteelBlue&gt;"..table.size(weapons).."&lt;DarkSlateGray&gt; weapons\n", [[gooey.vars.expandWeap = not gooey.vars.expandWeap gooey.funcs.gmcp.displayItems()]], "Expand or collapse this category", true)
    if gv.expandWeap == nil then 
      gv.expandWeap = true 
    end
    if gv.expandWeap then
      for id, value in pairs(weapons) do
      cechoPopup(console, " "..(gooey.funcs.getItemHighlight(id) or "").. value[1] .. "\n", {[[send("probe ]] .. id .. [[")]]}, {"Probe"}, true)
      end
    end
  end
  
  --if we're not on a ship, deal with denizens first
  cechoLink(console,"&lt;DarkSlateGray&gt;[&lt;SteelBlue&gt;"..((gv.expandDen and "-") or "+").."&lt;DarkSlateGray&gt;] &lt;SteelBlue&gt;"..table.size(gooey.data.gmcp.denizens).."&lt;DarkSlateGray&gt; denizens\n", [[gooey.vars.expandDen = not gooey.vars.expandDen gooey.funcs.gmcp.displayItems()]], "Expand or collapse this category", true)
  if gv.expandDen then
    for id, value in pairs(gooey.data.gmcp.denizens) do
      cechoPopup(console, " "..(gooey.funcs.getMobHighlight(id) or "").. value .. "\n", {[[gooey.funcs.setTarget("]] .. id .. [[") if keneanung then keneanung.bashing.addPossibleTarget("]]..value..[[") end ]], [[send("p ]] .. id .. [[")]], [[send("greet ]] .. id .. [[")]]}, {"Target", "Probe", "Greet"}, true)
    end
  end
  
  --deal with items - sigils
  local function getSigils(key, value)
    if string.find(value[1], "sigil") then
    return true
    end
  end
  
  local sigils = table.collect(gooey.data.gmcp.items, getSigils) 
  
  cechoLink(console,"&lt;DarkSlateGray&gt;[&lt;SteelBlue&gt;"..((gv.expandSigils and "-") or "+").."&lt;DarkSlateGray&gt;] &lt;SteelBlue&gt;"..table.size(sigils).."&lt;DarkSlateGray&gt; sigils\n", [[gooey.vars.expandSigils = not gooey.vars.expandSigils gooey.funcs.gmcp.displayItems()]], "Expand or collapse this category", true)
  if gv.expandSigils then
    for id, value in pairs(sigils) do
      cechoPopup(console, " "..(gooey.funcs.getItemHighlight(id) or "").. value[1] .. "\n", {[[send("probe ]] .. id .. [[")]], [[send("get ]] .. id .. [[")]]}, {"Probe", "Get"}, true)
    end
  end
  
  --deal with misc items (not sigils or gold or corpses)
  local function getMiscItems(key, value)
    if not getSigils(key, value) and 
      not string.find(value[1], "sovereign") and
      not string.starts(value[1], "the corpse of") and
      not getWeapons(key, value)
    then return true
    end
  end
  
  local miscItems = table.collect(gooey.data.gmcp.items, getMiscItems) 
  
  cechoLink(console,"&lt;DarkSlateGray&gt;[&lt;SteelBlue&gt;"..((gv.expandMiscItems and "-") or "+").."&lt;DarkSlateGray&gt;] &lt;SteelBlue&gt;"..table.size(miscItems).."&lt;DarkSlateGray&gt; misc items\n", [[gooey.vars.expandMiscItems = not gooey.vars.expandMiscItems gooey.funcs.gmcp.displayItems()]], "Expand or collapse this category", true)
  if gv.expandMiscItems then
    for id, value in pairs(miscItems) do
      cechoPopup(console, " "..(gooey.funcs.getItemHighlight(id) or "").. value[1] .. "\n", {[[send("probe ]] .. id .. [[")]], [[send("get ]] .. id .. [[")]]}, {"Probe", "Get"}, true)
    end
  end
  
  --deal with corpses
  local function getCorpses(key, value)
    if string.starts(value[1], "the corpse of") and 
      value[2] ~= "t"
    then return true
    end
  end
  
  local corpses = table.collect(gooey.data.gmcp.items, getCorpses) 
    
  local function getBodies(key, value)
    if string.starts(value[1], "the corpse of") and 
    value[2] == "t"
    then return true
    end
  end
  

  local bodies = table.collect(gooey.data.gmcp.items, getBodies) 
  
  cechoLink(console,"&lt;DarkSlateGray&gt;[&lt;SteelBlue&gt;"..((gv.expandCorpses and "-") or "+").."&lt;DarkSlateGray&gt;] &lt;SteelBlue&gt;"..table.size(corpses).."&lt;DarkSlateGray&gt; corpses"..(#bodies ~=0 and (" "..table.size(bodies).." bodies\n") or "\n"), [[gooey.vars.expandCorpses = not gooey.vars.expandCorpses gooey.funcs.gmcp.displayItems()]], "Expand or collapse this category", true)
  if gv.expandCorpses then
    for id, value in pairs(bodies) do
      cechoPopup(console, " "..(gooey.funcs.getItemHighlight(id) or "").. value[1] .. "\n", {[[send("probe ]] .. id .. [[")]], [[send("get ]] .. id .. [[")]]}, {"Probe", "Get"}, true)
    end
    for id, value in pairs(corpses) do
      cechoPopup(console, " "..(gooey.funcs.getItemHighlight(id) or "").. value[1] .. "\n", {[[send("probe ]] .. id .. [[")]], [[send("get ]] .. id .. [[")]]}, {"Probe", "Get"}, true)
    end
  end
  
  --deal with golds
    for id, value in pairs(gooey.data.gmcp.items) do
      if value[2]:find("sovereigns") then
      cechoPopup(console, " "..(gooey.funcs.getItemHighlight(id) or "").. value[1] .. "\n", {[[send("probe ]] .. id .. [[")]], [[send("get ]] .. id .. [[")]]}, {"Probe", "Get"}, true)
      end
    end
end

-- Function to display the list of people in the room
function gfg.displayRoomPlayers()
  clearUserWindow("peopleConsole")
  for key, value in pairs(gooey.data.gmcp.people) do
    cechoPopup("peopleConsole", value.."\n", {[[gooey.funcs.setTarget("]]..value..[[")]], [[send("greet ]]..value..[[")]]}, {"Target", "Greet"}, true)
  end
end

-- Function to update the players list
function gfg.updatePlayersList()
	gooey.data.gmcp.people = {}
  for k, v in pairs(gmcp.Room.Players) do
		if gmcp.Room.Players[k].name ~= gmcp.Char.Status.name then
 				table.insert(gooey.data.gmcp.people, gmcp.Room.Players[k].name)
		end 
	end 
end

-- Function to handle player addition
function gfg.handlePlayerAddition()
  table.insert(gooey.data.gmcp.people, gmcp.Room.AddPlayer.name)
  gooey.funcs.gmcp.displayRoomPlayers()
end

-- Function to handle player removal
function gfg.handlePlayerRemoval()
  for i, playerName in pairs(gooey.data.gmcp.people) do
    if playerName == gmcp.Room.RemovePlayer then
      table.remove(gooey.data.gmcp.people, i)
    break
    end
  end
  gooey.funcs.gmcp.displayRoomPlayers()
end

-- Function to manage the event handlers for items and people in the room
function gfg.inventoryeventmanager(event)

  if event == "gmcp.Char.Items.List" and gmcp.Char.Items.List.location == "room" then 
    gooey.funcs.gmcp.itemsList()
  elseif event == "gmcp.Char.Items.Add" and gmcp.Char.Items.Add.location == "room" then 
    gooey.funcs.gmcp.addItems()
  elseif event == "gmcp.Char.Items.Remove" and gmcp.Char.Items.Remove.location == "room" then 
    gooey.funcs.gmcp.removeItems()
  elseif event == "gmcp.Room.Players" then
    gooey.funcs.gmcp.updatePlayersList()
    gooey.funcs.gmcp.displayRoomPlayers()
  elseif event == "gmcp.Room.AddPlayer" then 
    gooey.funcs.gmcp.handlePlayerAddition()
  elseif event == "gmcp.Room.RemovePlayer" then 
    gooey.funcs.gmcp.handlePlayerRemoval()
  end

end

registerAnonymousEventHandler("gmcp.Char.Items.List","gooey.funcs.gmcp.inventoryeventmanager")
registerAnonymousEventHandler("gmcp.Char.Items.Add","gooey.funcs.gmcp.inventoryeventmanager")
registerAnonymousEventHandler("gmcp.Char.Items.Remove","gooey.funcs.gmcp.inventoryeventmanager")
registerAnonymousEventHandler("gmcp.Room.Players", "gooey.funcs.gmcp.inventoryeventmanager")
registerAnonymousEventHandler("gmcp.Room.AddPlayer", "gooey.funcs.gmcp.inventoryeventmanager")
registerAnonymousEventHandler("gmcp.Room.RemovePlayer", "gooey.funcs.gmcp.inventoryeventmanager")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Sea funcs</name>
				<packageName></packageName>
				<script>gooey.funcs = gooey.funcs or {}
gooey.funcs.sea = gooey.funcs.sea or {}
local gv = gooey.vars

function gooey.funcs.shipo(state)

if gv.ship.shipOn == nil then gv.ship.shipOn = false end



end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Activity funcs (mid left)</name>
				<packageName></packageName>
				<script>
function gooey.funcs.showActivity()
  local console = "gooey.gui.activityStatusConsole"
  clearUserWindow("console")
  
  if gooey.vars.sea.shipOn then
  
  
  
  
  elseif gooey.vars.hunt.hunting then
  
  
  
  elseif gooey.vars.combat.combating then
  
  
  end
end

</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Gooey Startup</name>
				<packageName></packageName>
				<script>
function gooey.funcs.formatAllContainers()
local myadjlabel = gooey.gui.styles[gooey.gui.myStyle].adjLabel
local mybuttonstyle = gooey.gui.styles[gooey.gui.myStyle].buttonstyle

  Adjustable.Container:doAll(function(s) 
    s:lockContainer("border")
    s.adjLabel:setStyleSheet(myadjlabel) 
    s.buttonstyle = mybuttonstyle
    s:setTitle("", "gray") 
    s:changeMenuStyle("dark")
    end)
    gooey.gui.roomNameLabel: setStyleSheet(myadjlabel)
    gooey.gui.roomNameLabel: setFormat("c13")
end

registerAnonymousEventHandler("sysLoadEvent", "gooey.funcs.formatAllContainers")


function gooey.funcs.startup()
  if not gooey.vars.gui.started then
    gooey.vars.gui.started = true
      sendGMCP([[Core.Supports.Add ["Comm.Channel 1"] ]])
      sendGMCP('Core.Supports.Add ["IRE.Tasks 1"]')
      sendGMCP('Core.Supports.Add ["IRE.Time 1"]')
      sendGMCP('Core.Supports.Add ["IRE.Misc 1"]')
      sendGMCP('Core.Supports.Add ["IRE.Display 1"]')
      sendGMCP('Core.Supports.Add ["IRE.Sound 1"]')
      sendGMCP('Core.Supports.Add ["IRE.Target 1"]')
    Adjustable.Container:doAll(function(s) s:addConnectMenu() end)
    --set the font sizes
    for k, v in pairs(gooey.gui) do 
      if gooey.gui[k].type == "miniConsole" or gooey.gui[k].type == "adjustablecontainer" then 
      local consoleName = gooey.gui[k].name
        gooey.gui.fontSize[consoleName] = gooey.gui.fontSize[consoleName] or 9
      setFontSize(gooey.gui[k].name, gooey.gui.fontSize[consoleName])
      end
    end
  end
end

registerAnonymousEventHandler("sysLoadEvent", "gooey.funcs.startup")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Misc utils</name>
				<packageName></packageName>
				<script>
    color_table.msGold        = {255,215,0}
    color_table.msSilver      = {160,160,160}
    color_table.a_darkred     = {128, 0, 0}
    color_table.a_darkgreen   = {0, 179, 0}
    color_table.a_brown       = {128, 128, 0}
    color_table.a_darkblue    = {0, 0, 128}
    color_table.a_darkmagenta = {128, 0, 128}
    color_table.a_darkcyan    = {0, 128, 128}
    color_table.a_grey        = {192, 192, 192}
    color_table.a_darkgrey    = {128, 128, 128}
    color_table.a_red         = {255, 0, 0}
    color_table.a_green       = {0, 255, 0}
    color_table.a_yellow      = {255, 255, 0}
    color_table.a_blue        = {0, 85, 255}
    color_table.a_magenta     = {255, 0, 255}
    color_table.a_cyan        = {0, 255, 255}
    color_table.a_white       = {255, 255, 255}
    color_table.a_darkwhite   = {192, 192, 192}
    color_table.a_darkyellow  = {179, 179, 0}
    color_table.a_onelevel    = {45, 46, 46}
    color_table.a_twolevel    = {103, 101, 98}
    color_table.a_threelevel  = {67, 48, 32}
    color_table.a_fourlevel   = {40, 186, 40}
    color_table.a_fivelevel   = {57, 140, 57}
    color_table.a_sixlevel    = {13, 121, 13}
    color_table.blaze_orange  = {255, 102, 0}

--Function that sets the gooey.target variable
function gooey.funcs.setTarget(what)
  send("st "..what, false)
  gooey.vars.target = what:title()
  gooey.echo("Target: &lt;LightSteelBlue&gt;"..what:title())
end

--Echo things in style 
function gooey.funcs.echo(text) 
  cecho("\n&lt;white&gt;(&lt;firebrick&gt;gooey&lt;white&gt;)&lt;reset&gt;: "..text.."\n")
end

--Function to alert about things in a more visible way than echoes
function gooey.funcs.alert(text, color1, color2) 
  color1 = color1 or "firebrick"
  color2 = color2 or "white"
  
  if not string.starts(color1, "&lt;") and color1 ~= "" then
    color1 = "&lt;"..color1.."&gt;"
  end
  
  if not string.starts(color2, "&lt;") and color2 ~= "" then
    color2 = "&lt;"..color2.."&gt;"
  end

  text = text or "Got asked to send an alert, but wasn't told what... so... BE ALERTED!"
  
  local leng = string.len(text)
    
  --draw the frame of the alert
  echo("\n")
  cecho(color1..string.rep("-", leng+2).."&lt;reset&gt;")
  echo("\n")
  
  --alert
  cecho(" "..color2..text:title().."&lt;reset&gt;")
  
  --bottom frame of the alert
  echo("\n")
  cecho(color1..string.rep("-", leng+2).."&lt;reset&gt;")
  echo("\n")
end

--Delete the line and the prompt following it
function gooey.funcs.deletelineP() 
  deleteLine()
  tempLineTrigger(1, 1, [[if isPrompt() then deleteLine() end]])
end

--List tables with a nice "or" or "and" (degault) at the end
function gooey.funcs.tableConcat(tbl, andor) 
  local index = 1
  local answer = ""
  andor = andor or "and"
    for k, v in pairs(tbl) do
      if type(k) == "number" then
        if index &lt; table.size(tbl)-1  then
          answer = answer..v..", "
          index = index + 1
        elseif index &lt; table.size(tbl)  then
          answer = answer..v.." "
          index = index + 1
        elseif index == table.size(tbl) then
          answer = answer.." "..andor.." "..v
        end
      else
        if index &lt; table.size(tbl)-1  then
          answer = answer..k..", "
          index = index + 1
        elseif index &lt; table.size(tbl)  then
          answer = answer..k.." "
          index = index + 1
        elseif index == table.size(tbl) then
          answer = answer.." "..andor.." "..k.."."
        end
      end
    end
  return answer  
end

--Function to round numbers to a certain number of decimals
function gooey.funcs.round(num, idp)
  local mult = 10^(idp or 0)
  return math.floor(num * mult + 0.5) / mult
end

--Function to toggle curing - except if no curing system it needs a state.
function gooey.funcs.pp(state) 
  if Legacy then
    if not state then
      state = Legacy.Settings.Curing.status
    else state = ((state == "on" and true) or false) 
    end
      send("curing "..(state and "on" or "off"))
  elseif svo then
    if not state then 
      state = not svo.conf.paused
    else state = (state == "on" and "off" or "on")
    svo.app(state)
    end
  else --no svo and no Legacy
    if not state then
      state = (gooey.vars.serverSettings.curingEnabled == "Yes" and "off" or "on")
    end
    send("curing "..state)
    echo(""..(state == "on" and "Unp"  or "P").."aused the system") 
  end
end

--Function to get the appropriate color for health based on health level
function gooey.funcs.healthColor(somehealththing, somehealththingmax)
if not somehealththing then
  if tonumber(gmcp.Char.Vitals.hp) &gt;= 2*tonumber(gmcp.Char.Vitals.maxhp)/3 then return "a_onelevel"
    elseif tonumber(gmcp.Char.Vitals.hp) &gt;= tonumber(gmcp.Char.Vitals.maxhp)/3 then return "ansiYellow"
    else return "firebrick"
  end
else
  if tonumber(somehealththing) &gt;= 2*tonumber(somehealththingmax)/3 then return "a_onelevel"
    elseif tonumber(somehealththing) &gt;= tonumber(somehealththingmax)/3 then return "ansiYellow"
    else return "firebrick"
  end
end
end

--get hex color codes - mostly used for hull/sails health
function gooey.funcs.getHealthColorHex(thing)
thing = tonumber(thing)
  if thing &lt; 40 then return "#FF0000"
  elseif thing &lt; 50 then return "#BD422E"
  elseif thing &lt; 70 then return "#E7A348"
  elseif thing &lt; 90 then return "#F3EC77"
  else return "#808000"
  end
end

--Function that gets us to full stats before sending a command (the command is optional)
function gooey.funcs.fl(dooncefull)
  if not gooey.vars.serverSettings.siphealth or not gooey.vars.serverSettings.sipmana then
    gooey.funcs.serverSettings.getServerSettings()
    gooey.funcs.echo("Whoops, gotta check your preferences first, standby...")
    gooey.vars.flwhat = dooncefull
  end
  if gooey.vars.gmcp.hp and gooey.vars.gmcp.hp &gt;= gooey.vars.gmcp.maxhp and gooey.vars.gmcp.mp and gooey.vars.gmcp.mp &gt;= gooey.vars.gmcp.maxmp then 
    if dooncefull == "gooey good to go" or not dooncefull then
      if not gooey.vars.flwhat then 
        gooey.vars.flwhat = "" 
      end
    else gooey.vars.flwhat = dooncefull
    end
    gooey.funcs.echo("We're full stats, yay! Doing &lt;orange&gt;"..(gooey.vars.flwhat == "" and "whatever we want now" or gooey.vars.flwhat).."&lt;reset&gt;.")
    expandAlias(gooey.vars.flwhat)
    gooey.vars.flwhat = nil
  else
    gooey.vars.flwhat = dooncefull
    tempTimer(0, [[gooey.funcs.getfull()]])
    gooey.funcs.echo("Getting full, hang on.")
  end
end

registerAnonymousEventHandler("gooey good to go", "gooey.funcs.fl")

function temp()
echo("gooey good to go was raised")
end
registerAnonymousEventHandler("gooey good to go", "temp")

--Function that sets curing for mana and health to max, so that serverside fills up our bars
function gooey.funcs.getfull()
  gooey.vars.checkVitals = true
  send("curing siphealth 99")
  send("curing sipmana 99") 
  gooey.funcs.goodtogo()
end

--Function that raises an event when we're full stats, and sets the curing back to its original state
function gooey.funcs.goodtogo()
  if gooey.vars.checkVitals then
  if gooey.vars.gmcp.hp and gooey.vars.gmcp.hp &gt;= gooey.vars.gmcp.maxhp and gooey.vars.gmcp.mp and gooey.vars.gmcp.mp &gt;= gooey.vars.gmcp.maxmp then
    raiseEvent("gooey good to go")
    gooey.vars.checkVitals = false
    send("curing siphealth "..gooey.vars.serverSettings.siphealth, false)
    send("curing sipmana "..gooey.vars.serverSettings.sipmana, false)
    gooey.funcs.echo("I set the curing stats back to what they were before.")
  end
  end
end

registerAnonymousEventHandler("gmcp.Char.Vitals", "gooey.funcs.goodtogo")

--Figure out what color to use for a player
function gooey.funcs.getPlayerHighlight(name)
	if name == target then
		return "&lt;blaze_orange&gt;"
	elseif svo then 
		return ndb.getcolor(name) 
  elseif Legacy then
    return Legacy.NDB.color(name)
	end
end

--Get the color for an item
function gooey.funcs.getItemHighlight(value)
  if value.attrib == "m" then 
    if value.id == target then return "&lt;blaze_orange&gt;" 
    else return "&lt;green&gt;" 
    end
  end
  if value.name and value.name:find("sovereign") ~= nil then return "&lt;gold&gt;" end
  if value.name and value.name:starts("the corpse of") then 
    if value.attrib == "t" then return "&lt;a_twolevel&gt;"
    else return "&lt;SlateGrey&gt;" 
    end
  end
end

--Get the color for a mob
function gooey.funcs.getMobHighlight(value)
  if (gooey.target and value == gooey.target) or (keneanung and keneanung.bashing.targetList[1] and value == keneanung.bashing.targetList[1].id) or (gmcp.IRE and gmcp.IRE.Target and value == gmcp.IRE.Target.Set) then 
    return "&lt;blaze_orange&gt;" 
    else return "&lt;green&gt;" 
  end
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>resetmarkx</name>
				<packageName></packageName>
				<script>function resetmarkx()
  markx = 0
end</script>
				<eventHandlerList>
					<string>gmcp.Char</string>
					<string>gmcp.Room.Info</string>
					<string>gmcp.IRE</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>gooey DenDB</name>
			<packageName></packageName>
			<script>gooey = gooey or {}
gooey.dendb = gooey.dendb or {}
gooey.dendb.db = gooey.dendb.db or {}

gooey.moduleHome = string.split(getModulePath("gooey"), "gooey.*%.xml")[1]

function gooey.dendb.managedb(thing)
  if gmcp and gmcp.Room and gmcp.Room.Info then
  gooey.dendb.db[gmcp.Room.Info.area] = gooey.dendb.db[gmcp.Room.Info.area] or {}
    if not string.find(thing, "homunculus") and 
      thing ~= "an aklan servitor"
    then
      gooey.dendb.db[gmcp.Room.Info.area][thing] = gooey.dendb.db[gmcp.Room.Info.area][thing] or {}
      if not table.contains(gooey.dendb.db[gmcp.Room.Info.area][thing], gmcp.Room.Info.num) then
        table.insert(gooey.dendb.db[gmcp.Room.Info.area][thing], gmcp.Room.Info.num)
      end
    end
  end
end</script>
			<eventHandlerList />
		</Script>
	</ScriptPackage>
	<KeyPackage>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>gooey</name>
			<packageName></packageName>
			<script></script>
			<command></command>
			<keyCode>33554431</keyCode>
			<keyModifier>0</keyModifier>
		</KeyGroup>
	</KeyPackage>
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
